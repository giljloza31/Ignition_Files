from shared.tools.thread import async
from shared.tools.global import ExtraGlobal
from functools import partial
	
from time import sleep
from random import random
from datetime import datetime
from time import sleep
from random import random
from datetime import datetime
from Database import db_access
from java.util import Date
import re

PAYLOAD_SEPERATOR = '|'
BARCODE_SEPERATOR = ','
ERROR = ''

db_name = 'MongoWCS'

class RoutingException(Exception):
	pass
	
class NOPAYLOAD(RoutingException):pass

class NOREAD(RoutingException):pass

class NODEST(RoutingException):pass

class NORETURN(RoutingException):pass

class MULTI(RoutingException):pass



def log_data(data):
	
	
	indexID = data['IGN_IndexID_Returned']
	payload = data['IGN_Payload_Returned']
	gap = 0
	length = 0
	dest = data['IGN_Destination_Returned']
	destString = data['IGN_Dest_String_Returned']
	route = data['IGN_Route_Returned']
	Route_Reason = data['Route_Reason']
	Route_Reason_Num = data['Route_Reason_Num']
	start = data['Received_Data_Time']
	stop = system.date.now()
	stopFormat = system.date.format(stop, "yyyy-MM-dd HH:mm:ss")
	#system.db.runNamedQuery('Scanner/Scan1/Insert_TrackingTable',{'inVarIndexID':indexID,'inVarPayload':payload,'inVarGap':gap,'inVarLength':length,'inVarDest':dest,'inVarDestString':destString,'inVarRoute': route,'inVarRouteReason':Route_Reason,'inVarRouteReasonNum':Route_Reason_Num,'inVarQueryms':system.date.millisBetween(start, stop)})
	query = '''
	Insert into Scan1_Tracking_Table( 
	IndexID,Payload,Gap,Length,Dest_Binary_Returned,Dest_String_Returned,Route_Returned,Route_Reason,Route_Reason_Num,Divert_Path,Divert_Path_String,Divert_Reason_String,
	Divert_Reason_Num,Induct_TimeStamp,Divert_TimeStamp,Query_Time_ms,Travel_Time_ms)
	Values ( ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)'''	
	
	args = [indexID , payload , gap , length , dest , destString , route , Route_Reason , Route_Reason_Num ,0,'','',0,stopFormat,'' ,system.date.millisBetween(start, stop),0]
	
	system.db.runPrepUpdate(query, args, 'SQLServer')
	
def error_lookup(data,ERROR):
	
	query = """
	SELECT *
	FROM Scan1_Divert_Table
	Where Route_Code = ?
	"""
	results = system.db.runPrepQuery(query, [ERROR], 'SQLServer')

	# Decode the results
			
	# We get only one result if any because of the UNIQUE constraint on the table
	row = results[0]
	
	
	# Get RoutedPaylod
	
	routedString = row['Route_Code']
	# Decode the Divert columns into a bit array int
	
	# Start with no routes
	destinations = 0
	
	# Start with an Empty list for the selected Diverts
	divert_list = []
	divert_String = ''
	for selected,columnName in zip(row, results.columnNames):
		
		#Loop through and find where route is divert is selected	
		if not columnName.startswith('Divert_'): # TODO: Fix column names to match		
			continue
				
		# Get the second half on the underscore.
		# (rpartition splits on a thing, always retruning
		#  the left, split thing, and right of it)
		# And make it an int so we can shift on it
		# ... minus one because we are zero indexed, and lanes are one-indexed
		shift = int(columnName.rpartition('_')[2]) - 1 # TODO: Fix column names to match
		if row[columnName]:
			divert_list.append(columnName)
		#shift = int(columnName[-2:]) - 1
	
		# Take the result bit array so far, 
		#  and or it with the value SQL returned, 
		#  bit shifted the number of lanes 
		destinations |= selected << shift
	
	
	if destinations == 0:
		data.update({
		'Route_Reason':"Found Route No Lane Assigned",
		'Route_Reason_Num':5
		})	
		
	divert_String = '|'.join(divert_list)
	
			
	data.update({
		'IGN_Destination_Returned': destinations,
		'IGN_Route_Returned':routedString,
		'IGN_Dest_String_Returned': divert_String,
		'IGN_Payload_Returned':data['IGN_RawPayload']

	})
		

	return data
	
def decode_results(data):
	#Change the name of the divert table
	query = """
	SELECT *
	FROM Scan1_Divert_Table
	Where Route_Code = ?
	"""
	results = system.db.runPrepQuery(query, [data['IGN_Route_Returned']], 'SQLServer')
	
	if not results:
		raise NODEST
		
		
		
	# Decode the results
			
	# We get only one result if any because of the UNIQUE constraint on the table
	row = results[0]
	
	# Return the Routed string
	routedString = row['Route_Code']
		
	
	# Decode the Divert columns into a bit array int
	# Start with no routes	
	destinations = 0
	
	# Start with an Empty list for the selected Diverts
	divert_list = []
	divert_String = ''
	for selected,columnName in zip(row, results.columnNames):
		
	
		if not columnName.startswith('Divert_'): # TODO: Fix column names to match		
			continue
			
		# Get the second half on the underscore.
		# (rpartition splits on a thing, always retruning
		#  the left, split thing, and right of it)
		# And make it an int so we can shift on it
		# ... minus one because we are zero indexed, and lanes are one-indexed
		shift = int(columnName.rpartition('_')[2]) - 1 # TODO: Fix column names to match
		if row[columnName]:
			divert_list.append(columnName)
		#shift = int(columnName[-2:]) - 1
	
		# Take the result bit array so far, 
		#  and or it with the value SQL returned, 
		#  bit shifted the number of lanes 
		destinations |= selected << shift
	
	if destinations == 0:
		data.update({
		'Route_Reason':"Found %s Route No Lane Assigned"%(data['IGN_Route_Returned']),
		'Route_Reason_Num':5
		})
		
	divert_String = '|'.join(divert_list)
	
			
	data.update({
		'IGN_Destination_Returned': destinations,
		'IGN_Dest_String_Returned': divert_String
		})
		
	return data	


def lookup(data,barcodeList):
	
	barcodestring = ''
	filter={
	   "_id":{'$in':barcodeList}
	}
	project={
    	'_id': 1, 
	   
	    'consol_zone':1,
	    
	}
	
	IBNResults = db_access.select_records(db_name,'outbound_scan_sort_ibn',where_clause=filter,projection=project)

	IBNCount = len(IBNResults)

	
	
	if IBNCount==0:
		raise NORETURN
		
	barcodestring = ','.join(barcodeList)

	RoutedBarcode = barcodestring
	RouteReturned = IBNResults[0]['consol_zone']
	
	data.update({
	'IGN_Route_Returned':RouteReturned,
	'IGN_Payload_Returned':RoutedBarcode
	})
	
	data.update(decode_results(data))
	
	
	return data
	
	

def lookup_and_decode(data,payload):
	rawList = []
	barcodeList = []

	if BARCODE_SEPERATOR in payload:
	
		rawList = payload.split(BARCODE_SEPERATOR)
	else:
		rawList.append(payload)


	if rawList[0]=='??????':
			raise NOREAD
	else:
		for code in rawList:
			if len(code) == 6 and code != 'NOREAD':
				if code not in barcodeList:
					barcodeList.append(code)
	
	if len(barcodeList) == 0:
		raise NOREAD

	data.update(lookup(data,barcodeList))		
		
	
	return data
#Change the name per use "(projectname)_gather_Data"	
@async(name = "Scan1_gather_Data")	
def Scan1_gather_data(source_path):
	
	ReceiveTime = system.date.now()
	Get_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	Got_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
	Get_Counts = '/'.join(source_path.split('/')[:-2] + ['Got_Data/Counts'])
	
		
	

	rawPayload,errorCNT,multiCNT,nodestCNT,nopayloadCNT,noreadCNT,noreturnCNT,norouteCNT,successCNT,code_exc,dvt1,dvt2,dvt3,dvt4= [

	qv.value for qv in 
	system.tag.readBlocking([
		Get_parent_dest + '/' + 'IGN_Payload_Sent',
		Get_Counts + '/' + 'ERROR',
		Get_Counts + '/' + 'MULTI',
		Get_Counts + '/' + 'NODEST',
		Get_Counts + '/' + 'NOPAYLOAD',
		Get_Counts + '/' + 'NOREAD',
		Get_Counts + '/' + 'NORETURN',
		Get_Counts + '/' + 'NOROUTE',
		Get_Counts + '/' + 'SUCCESS',
		Get_Counts + '/' + 'CODE_EXC',
		Get_Counts + '/' + 'DVT_1',
		Get_Counts + '/' + 'DVT_2',
		Get_Counts + '/' + 'DVT_3',
		Get_Counts + '/' + 'DVT_4',
	])]

	data = {
		'Route_Reason':"Successful Lookup",
		'Route_Reason_Num':0,
		'errorCNT':int(errorCNT),
		'multiCNT':int(multiCNT),
		'nodestCNT':int(nodestCNT),
		'nopayloadCNT':int(nopayloadCNT),
		'noreadCNT':int(noreadCNT),
		'noreturnCNT':int(noreturnCNT),
		'norouteCNT':int(norouteCNT),
		'successCNT':int(successCNT),
		'code_exc':int(code_exc),
		'dvt1':int(dvt1),
		'dvt2':int(dvt2),
		'dvt3':int(dvt3),
		'dvt4':int(dvt4)
		}
	
	try:
		if PAYLOAD_SEPERATOR in rawPayload:
			indexID,payload = rawPayload.split(PAYLOAD_SEPERATOR)
			
			
			payload = payload.replace("\x02", "").replace("\x03", "")
			
			data.update({
			'IGN_IndexID_Returned':indexID,
			'IGN_RawPayload':payload
			})
		else:
			raise NOPAYLOAD
			
		
		data.update(lookup_and_decode(data,payload))
	
	except NOPAYLOAD:
		ERROR = 'NOPAYLOAD'
		data.update({
		'IGN_IndexID_Returned':99,
		'IGN_RawPayload':rawPayload})
		data.update(error_lookup(data,ERROR))
		payload = rawPayload
		
		data.update({
		'Route_Reason':"Wrong Payload Received",
		'Route_Reason_Num':2,
		'nopayloadCNT':data['nopayloadCNT']+1
		})
	except NOREAD:
		ERROR = 'NOREAD'
		data.update(error_lookup(data,ERROR))
		
		data.update({
		'Route_Reason':"Scanner Found No Barcodes",
		'Route_Reason_Num':3,
		'noreadCNT':data['noreadCNT']+1
		})
	except NORETURN:
		ERROR = 'NORETURN'
		
		data.update(error_lookup(data,ERROR))
		data.update({
		'Route_Reason':"No Results found in Production Table",
		'Route_Reason_Num':4,
		'noreturnCNT':data['noreturnCNT']+1
		})
	except NODEST:
		ERROR = 'NODEST'
		
		data.update(error_lookup(data,ERROR))
		data.update({
		'Route_Reason':"%s Route not in Divert Table"%(data['IGN_Route_Returned']),
		'Route_Reason_Num':6,
		'nodestCNT':data['nodestCNT']+1
		})		
	except MULTI:
		ERROR = 'MULTI'
		
		data.update(error_lookup(data,ERROR))
		data.update({
		'Route_Reason':"Multiple routes found",
		'Route_Reason_Num':6,
		'multiCNT':data['multiCNT']+1
		})	
	except:
		ERROR = 'ERROR'
		data.update(error_lookup(data,ERROR))
		
		data.update({
		'IGN_IndexID_Returned':99,
		'IGN_RawPayload':rawPayload,
		'Route_Reason':"Unexpected Error",
		'Route_Reason_Num':1,
		'errorCNT':data['errorCNT']+1
		})
	
	
	data.update({
	'Received_Data_Time':ReceiveTime,
	'Sent_Data_Time':system.date.now()
	})
	
	if data['Route_Reason_Num'] == 0:
		
		data.update({
			'successCNT':data['successCNT']+1
			})
	elif data['Route_Reason_Num'] == 5:
		
		data.update({
			'nodestCNT':data['nodestCNT']+1
			})
	
	data.update({
	'code_exc':data['code_exc']+1
	})
	
	
	if data['IGN_Destination_Returned']==1:
		data.update({'dvt1':data['dvt1']+1})
	elif data['IGN_Destination_Returned']==2:
		data.update({'dvt2':data['dvt2']+1})
	elif data['IGN_Destination_Returned']==4:
		data.update({'dvt3':data['dvt3']+1})
	elif data['IGN_Destination_Returned']==8:
		data.update({'dvt4':data['dvt4']+1})
		
	data['TOTAL'] = data['errorCNT']+data['multiCNT']+data['nodestCNT']+data['nopayloadCNT']+data['noreadCNT']+data['noreturnCNT']+data['norouteCNT']+data['successCNT']
	
	Got_parent_dest += '/'
	Get_Counts += '/'
	
	system.tag.writeBlocking(*zip(*[
		(Got_parent_dest + 'IGN_IndexID_Returned', data['IGN_IndexID_Returned']),	
		(Got_parent_dest + 'IGN_Route_Returned', data['IGN_Route_Returned']),			
		(Got_parent_dest + 'IGN_Payload_Returned', data['IGN_Payload_Returned']),	
		(Got_parent_dest + 'IGN_Destination_Returned', data['IGN_Destination_Returned']),	
		(Got_parent_dest + 'IGN_Dest_String_Returned', data['IGN_Dest_String_Returned']),
		(Get_Counts  + 'CODE_EXC',data['code_exc']),
		(Get_Counts  + 'ERROR',data['errorCNT']),
		(Get_Counts  + 'MULTI',data['multiCNT']),
		(Get_Counts  + 'NODEST',data['nodestCNT']),
		(Get_Counts  + 'NOPAYLOAD',data['nopayloadCNT']),
		(Get_Counts  + 'NOREAD',data['noreadCNT']),
		(Get_Counts  + 'NORETURN',data['noreturnCNT']),
		(Get_Counts  + 'NOROUTE',data['norouteCNT']),
		(Get_Counts  + 'SUCCESS',data['successCNT']),
		(Get_Counts  + 'TOTAL',data['TOTAL']),
		(Get_Counts  + 'DVT_1',data['dvt1']),
		(Get_Counts  + 'DVT_2',data['dvt2']),
		(Get_Counts  + 'DVT_3',data['dvt3']),
		(Get_Counts  + 'DVT_4',data['dvt4'])
	]))
		
	itemPaths = [
	'ns=1;s=[L330ER_Opex_OIO]PWD_HMIInt'
	]
	
	values = [
	data['IGN_Destination_Returned']
	]
	# Add in OPC writes
	system.opc.writeValues('Ignition OPC-UA Server', itemPaths, values)
	

	log_data(data)








