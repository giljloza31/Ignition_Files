

from shared.data.types.dictslots import DictSlotsMixin
from shared.data.types.mixins import ImmutableDictMixin

from itertools import izip_longest


def chain_attribute(dict_like, key_path, default=None):
	cursor = dict_like
	try:
		for key in key_path.split('.'):
			cursor = cursor[key]
	except KeyError:
		return default
	return cursor




class ImmutableOverridableDictSlots(ImmutableDictMixin, DictSlotsMixin):
	_slot_alias = {}
	
	def __init__(self, *slot_values, **overrides):
		for slot, value in izip_longest(self.__slots__, slot_values, fillvalue=None):
			setattr(self, slot, 
				chain_attribute(
					overrides, 
					self._slot_alias.get(slot, slot),
					default=value)
			)



class Histogram(ImmutableOverridableDictSlots):
	__slots__ = tuple(slot.strip() for slot
		in """
			start stop step
			outliers
			counts
		""".split())
		
	def __repr__(self):
		return '<Histogram [%r: %r: %r] %d out (of %d)>' % (
			self.start, self.stop, self.step, self.outliers, len(self.counts) )


class StatisticalDescription(ImmutableOverridableDictSlots):
	__slots__ = tuple(slot.strip() for slot
		in """
			n mean 
			min max span
			variance stddev
			sum 
			histogram
		""".split())
	
	_slot_alias = {
		'stddev':   'standard deviation',
	}






from io import BytesIO
from StringIO import StringIO

from java.lang import Exception as JavaException

#from shared.data.binary.handlers.stream import StreamHandler
from shared.data.binary.handlers.numeric import LongHandler, FloatHandler
from shared.data.binary.handlers.helper import UnsignedIntTupleAsLongHandler


class HistogramHandler(
		FloatHandler,
		UnsignedIntTupleAsLongHandler,
		LongHandler,
	):
	def write_histogram(self, histogram):
		#with self.file_mode('ab'):
		self.write_float(histogram.start)
		self.write_float(histogram.stop)
		self.write_float(histogram.step)
		counts = self.encode_long_from_tuple_of_unsigned_ints(
			(histogram.outliers+1,) + tuple(i + 1 for i in histogram.counts)
		)
		self.write_long(counts)
		
	def read_histogram(self):
		#with self.file_mode('rb'):
		start, stop, step = self.read_float(), self.read_float(), self.read_float(),
		outliers_and_counts = self.decode_tuple_of_unsigned_ints_from_long(self.read_long())
		outliers = outliers_and_counts[0] - 1
		counts = tuple(x - 1 for x in outliers_and_counts[1:])
		return Histogram(start, stop, step, outliers, counts)

class StatisticalDescriptionBincoder(
		HistogramHandler,
		FloatHandler,
		LongHandler,
	):
	def write_statistical_description(self, sd):
		self.write_long(sd.n)
		for x in 'mean min max span variance stddev sum'.split():
			self.write_float(sd[x])
		self.write_histogram(sd.histogram)
		
	def read_statistical_description(self):
		return StatisticalDescription(
			*((self.read_long(),) + tuple(self.read_float() 
				for x in 'mean min max span variance stddev sum'.split()
			) + (self.read_histogram(),))
		)


def _run_tests():
	
	from shared.tools.monitoring.context.statistics import Histogram, StatisticalDescription
	from shared.tools.monitoring.context.statistics import StatisticalDescriptionBincoder
	
	entry = {
			"histogram": {
				"counts": [0, 0, 0, 0, 6, 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
				"outliers": 0
			},
			"min": 49.5453,
			"max": 51.0179,
			"variance": 0.21236614115789482,
			"mean": 50.35886999999999,
			"sum": 1007.1773999999998,
			"n": 20,
			"standard deviation": 0.460832009693223,
			"span": 1.4726
		}
	
	resolved_entry = entry.copy()
	resolved_entry['histogram'] = Histogram(
		counts=entry['histogram']['counts'], 
		outliers=entry['histogram']['outliers'], 
			**{
				"stop": 95,
				"start": 45,
				"step": 1
			})
	
	sd = StatisticalDescription(**resolved_entry)
	
	
	stream = BytesIO()
	
	bincoder = StatisticalDescriptionBincoder()
	bincoder.stream = stream
	
	
	bincoder.write_statistical_description(sd)
	bincoder.stream.seek(0)
	sd2 = bincoder.read_statistical_description()
	
	
	assert sd2.asdict() == sd.asdict()
