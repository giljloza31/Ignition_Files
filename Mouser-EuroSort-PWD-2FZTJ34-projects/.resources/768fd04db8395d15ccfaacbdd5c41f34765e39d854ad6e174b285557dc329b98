from shared.tools.global import ExtraGlobal
from shared.tools.thread import async
from shared.tools.meta import is_redundant_active
from functools import partial
from Database import db_access
from time import sleep
from random import random
from datetime import datetime


from java.util import Date

import re
import socket


CACHE_LIFESPAN = 3.0 # seconds
db_name = 'MongoWCS'
CLEAR_WAIT_TIME  = 0.026
FAILSAFE_TIMEOUT = 6.0


class RoutingException(Exception):
	pass

class NoMatchingRoute(RoutingException):
	def _init_(self,data,barcode):
		self.data = data
		self.barcode = barcode

class NoMatchingRule(RoutingException):
	def _init_(self,weight,barcode):
		self.data = data
		self.barcode = barcode

class MultipleMatchingRules(RoutingException):
	def _init_(self,data,barcode):
		self.data = data
		self.barcode = barcode

class AmbiguousRoute(RoutingException):
	def _init_(self,data,barcode):
		self.data = data
		self.barcode = barcode

class NOIBN(RoutingException):
	def _init_(self,data,barcode):
		self.data = data
		self.barcode = barcode

class TOTE_LOOKUP(RoutingException):
	def _init_(self,data,barcode):
		self.data = data
		self.barcode = barcode

class NOREAD(RoutingException):
	def _init_(self,data,tote,barcode):
		self.data = data
		self.barcode = barcode
		self.tote = tote

class AUTOSTORE(RoutingException):
	def _init_(self,weight,Barcode):
		self.data = data
		self.barcode = barcode


def log_event(mode, data):
	results = system.db.runPrepUpdate("""
		insert into Handshake_Log (
			mode
		,	barcode
		,	routecode
		,	destination
		,	seq
		,	get_time
		,	got_time
		,	sql_time
		) values (?,?,?,?,?,?,?,?)	
		""",[
			mode
		,	data['IGN_Barcode_Returned']
		,	data.get('IGN_RouteCode_Returned', data.get('RouteCode_Returned'))
		,	data['IGN_Destination_Returned']
		,	data['IGN_IndexID_Returned']		
		,	data.get('Get_Time')		
		,	data.get('Got_Time')
		,	data.get('Sql_Time')
		], 'SQLServer')
		


def yellow_data_lookup_and_decode(raw_barcode,data):
	

	ERROR_BARCODES = ['', 'NOREAD']
	SEPATATOR_PATTERN = ','

	routing_barcodes = []
	tote_query = []
	
	if not raw_barcode:
		raise NOIBN(data,raw_barcode)
	
	
	if raw_barcode == "NOREA":
		raise NOREAD(data,raw_barcode)

   	elif SEPATATOR_PATTERN in raw_barcode:
   		for token in SEPATATOR_PATTERN.split(raw_barcode):
   			if token.startswith("RVT") or token.startswith("TSBX"):
   				tote_query.append(token)
				if raw_barcode.startswith("RVT"):
					tote = 'RVT'
				else:
					tote = 'TSBX'
				raise TOTE_LOOKUP(data,tote,raw_barcode)
 
   			elif re.match('[0-9A-Z]{6}',token):
   				if token not in routing_barcodes:
   					routing_barcodes.append(token)
	else:
		if raw_barcode.startswith("RVT") or raw_barcode.startswith("TSBX"):
			tote_query.append(raw_barcode)
			if raw_barcode.startswith("RVT"):
				tote = 'RVT'
			else:
				tote = 'TSBX'
			raise TOTE_LOOKUP(data,tote,raw_barcode)
		elif re.match('[0-9A-Z]{6}',raw_barcode):
			if raw_barcode not in routing_barcodes:
				routing_barcodes.append(raw_barcode)



	if not routing_barcodes and not tote_query:
		raise NOIBN(data,raw_barcode)


	

	filter = {
		"_id":{"$in":routing_barcodes}
		}
	project = {

		"_id":1,
		"sort_size":1,
		"zone":1,

	}

	IBNQuery = db.inbound_receipt_info.find(
		filter=filter,
		projection=project
	)
			
	IBNresults = db_access.select_records(db_name,'inbound_receipt_info',where_clause=filter,projection=project)

	IBNCount = len(IBNresults)					
	
	if IBNCount == 0:
		raise NOIBN(data,raw_barcode)

	elif IBNCount >= 2:
		raise MultipleMatchingRules(data,raw_barcode)

	elif IBNCount == 1:	
		
		data.update({
			'sortsize':IBNresults[0]['sort_size'],
			'IGN_Barcode_Returned':IBNresults[0]['_id'],
			'RouteCode_Returned':IBNresults[0]['zone']
			})
		
		

	else:
		raise AmbiguousRoute(data,raw_barcode)


	system.util.getLogger('Yellow Receiving Error').trace(data['RouteCode_Returned'])
	if data['RouteCode_Returned'] == "AU":
		
		raise AUTOSTORE(data,raw_barcode)
		
	else:
		results = system.db.runPrepQuery("""
			select r.*
			from route_table1 as r
			where r.route_code = ?
			""", [data['RouteCode_Returned']],'SQLServer')
		
	
		
	
		# if a route wasn't found, then fail back to direct route data
		if not results:
			raise NoMatchingRoute(data,raw_barcode)		


	
	
		row = results[0]
			
			# Start with no routes	
		bitArray = 0
		route_code = ''
		for selected,columnName in zip(row, results.columnNames):
				
			if columnName == 'Route_Code':
				route_code = selected
				continue
		
			if not columnName.startswith('Lane_'):
				continue
			
			# Get the second half on the underscore.
			# (rpartition splits on a thing, always retruning
			#  the left, split thing, and right of it)
			# And make it an int so we can shift on it
			# ... minus one because we are zero indexed, and lanes are one-indexed
			shift = int(columnName.rpartition('_')[2]) - 1
		
			# Take the result bit array so far, 
			#  and or it with the value SQL returned, 
			#  bit shifted the number of lanes 
			bitArray |= selected << shift


		data.update({
		'IGN_Destination_Returned': bitArray,	
		'IGN_GotData_Returned': True,
		})

	return data



			
@async(name="Yellow_gather_data")
def Yellow_gather_data(source_path):
	data = {}
	timestart = datetime.now().isoformat()
	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	sequence_id, raw_barcode = [
		qv.value for qv in 
		system.tag.readBlocking([
			parent_dest + '/' + 'IGN_IndexID_Sent',
			parent_dest + '/' + 'IGN_Barcode_Sent'
			])]

	system.tag.writeAsync([parent_dest + '/' + 'IGN_GetData_ACK'], [True])

	data.update({

		'IGN_IndexID_Returned':sequence_id,

	})



	try:
		data.update(yellow_data_lookup_and_decode(raw_barcode,data))


	except (NOIBN,AmbiguousRoute) as logs:
		zone = "NOIBN"
		results = system.db.runPrepQuery("""
		select r.*
		from route_table1 as r
		where r.route_code = ?
		""", [zone],'SQLServer')


		row = results[0]
		
		# Start with no routes	
		bitArray = 0
		route_code = ''
		for selected,columnName in zip(row, results.columnNames):
				
			if columnName == 'Route_Code':
				route_code = selected
				continue
		
			if not columnName.startswith('Lane_'):
				continue
			
			# Get the second half on the underscore.
			# (rpartition splits on a thing, always retruning
			#  the left, split thing, and right of it)
			# And make it an int so we can shift on it
			# ... minus one because we are zero indexed, and lanes are one-indexed
			shift = int(columnName.rpartition('_')[2]) - 1
		
			# Take the result bit array so far, 
			#  and or it with the value SQL returned, 
			#  bit shifted the number of lanes 
			bitArray |= selected << shift

		data.update({
		'IGN_Barcode_Returned':logs[1],
		'IGN_Destination_Returned': bitArray,	
		'IGN_GotData_Returned': True,
		'RouteCode_Returned':"NOIBN"
		})

	except NoMatchingRoute as logs:
		zone = "NODESTINATION"
		results = system.db.runPrepQuery("""
		select r.*
		from route_table1 as r
		where r.route_code = ?
		""", [zone],'SQLServer')


		row = results[0]
		
		# Start with no routes	
		bitArray = 0
		route_code = ''
		for selected,columnName in zip(row, results.columnNames):
				
			if columnName == 'Route_Code':
				route_code = selected
				continue
		
			if not columnName.startswith('Lane_'):
				continue
			
			# Get the second half on the underscore.
			# (rpartition splits on a thing, always retruning
			#  the left, split thing, and right of it)
			# And make it an int so we can shift on it
			# ... minus one because we are zero indexed, and lanes are one-indexed
			shift = int(columnName.rpartition('_')[2]) - 1
		
			# Take the result bit array so far, 
			#  and or it with the value SQL returned, 
			#  bit shifted the number of lanes 
			bitArray |= selected << shift

		data.update({
		'IGN_Barcode_Returned':logs[1],
		'IGN_Destination_Returned': bitArray,	
		'IGN_GotData_Returned': True,
		'RouteCode_Returned':"NODESTINATION"
		})
		
	except TOTE_LOOKUP as logs:
		
		zone = logs[1]
		results = system.db.runPrepQuery("""
		select r.*
		from route_table1 as r
		where r.route_code = ?
		""", [zone],'SQLServer')


		row = results[0]
		
		# Start with no routes	
		bitArray = 0
		route_code = ''
		for selected,columnName in zip(row, results.columnNames):
				
			if columnName == 'Route_Code':
				route_code = selected
				continue
		
			if not columnName.startswith('Lane_'):
				continue
			
			# Get the second half on the underscore.
			# (rpartition splits on a thing, always retruning
			#  the left, split thing, and right of it)
			# And make it an int so we can shift on it
			# ... minus one because we are zero indexed, and lanes are one-indexed
			shift = int(columnName.rpartition('_')[2]) - 1
		
			# Take the result bit array so far, 
			#  and or it with the value SQL returned, 
			#  bit shifted the number of lanes 
			bitArray |= selected << shift

		data.update({
		'IGN_Barcode_Returned':logs[2],
		'IGN_Destination_Returned': bitArray,	
		'IGN_GotData_Returned': True,
		'RouteCode_Returned':logs[1]
		})
	except NOREAD as logs:
		zone = "NOREAD"
		results = system.db.runPrepQuery("""
		select r.*
		from route_table1 as r
		where r.route_code = ?
		""", [zone],'SQLServer')


		row = results[0]
		
		# Start with no routes	
		bitArray = 0
		route_code = ''
		for selected,columnName in zip(row, results.columnNames):
				
			if columnName == 'Route_Code':
				route_code = selected
				continue
		
			if not columnName.startswith('Lane_'):
				continue
			
			# Get the second half on the underscore.
			# (rpartition splits on a thing, always retruning
			#  the left, split thing, and right of it)
			# And make it an int so we can shift on it
			# ... minus one because we are zero indexed, and lanes are one-indexed
			shift = int(columnName.rpartition('_')[2]) - 1
		
			# Take the result bit array so far, 
			#  and or it with the value SQL returned, 
			#  bit shifted the number of lanes 
			bitArray |= selected << shift

		data.update({
		'IGN_Barcode_Returned':"NOREAD",
		'IGN_Destination_Returned': bitArray,	
		'IGN_GotData_Returned': True,
		'RouteCode_Returned':"NOREAD"
		
		})

	except MultipleMatchingRules as logs:
		zone = "MULTIPLEIBN"
		results = system.db.runPrepQuery("""
		select r.*
		from route_table1 as r
		where r.route_code = ?
		""", [zone],'SQLServer')


		row = results[0]
		
		# Start with no routes	
		bitArray = 0
		route_code = ''
		for selected,columnName in zip(row, results.columnNames):
				
			if columnName == 'Route_Code':
				route_code = selected
				continue
		
			if not columnName.startswith('Lane_'):
				continue
			
			# Get the second half on the underscore.
			# (rpartition splits on a thing, always retruning
			#  the left, split thing, and right of it)
			# And make it an int so we can shift on it
			# ... minus one because we are zero indexed, and lanes are one-indexed
			shift = int(columnName.rpartition('_')[2]) - 1
		
			# Take the result bit array so far, 
			#  and or it with the value SQL returned, 
			#  bit shifted the number of lanes 
			bitArray |= selected << shift

		data.update({
		'IGN_Barcode_Returned':logs[1],
		'IGN_Destination_Returned': bitArray,	
		'IGN_GotData_Returned': True,
		'RouteCode_Returned':"MULTIPLEIBN"
		})

	except AUTOSTORE as logs:
		

		data = logs[0]
		Autostore_results = system.db.runPrepQuery("""
			select *
			from AutoStore_RouteTable
			where Route_Code = ? and BoxSize = ?
			""", [data['RouteCode_Returned'],data['sortsize']],'SQLServer')
			
		
		if 	Autostore_results:
			row = Autostore_results[0]
			try:
				Dim_results = system.db.runPrepQuery("""
					select IBN,Length,Width,Height
					from Dimensioner_InductSorter_1
					where IBN = ?
					""", [ibn],'SQLServer')
					
				dim_row = Dim_results[0]
				length = (float(dim_row['Length'])/10)
				width = (float(dim_row['width'])/10)
				height = (float(dim_row['height'])/10)
			except:
				length = 12.5
				width = 12.5
				height = 12.5
		
		if height >= 12.5:
			bitArray = (1<<(7-1))
		else:
			bitArray = row['Binary_Destination']


		data.update({
			'IGN_Destination_Returned': bitArray,	
			'IGN_GotData_Returned': True,
			})

	except:
		zone = "NOIBN"
		results = system.db.runPrepQuery("""
		select r.*
		from route_table1 as r
		where r.route_code = ?
		""", [zone],'SQLServer')


		row = results[0]
		
		# Start with no routes	
		bitArray = 0
		route_code = ''
		for selected,columnName in zip(row, results.columnNames):
				
			if columnName == 'Route_Code':
				route_code = selected
				continue
		
			if not columnName.startswith('Lane_'):
				continue
			
			# Get the second half on the underscore.
			# (rpartition splits on a thing, always retruning
			#  the left, split thing, and right of it)
			# And make it an int so we can shift on it
			# ... minus one because we are zero indexed, and lanes are one-indexed
			shift = int(columnName.rpartition('_')[2]) - 1
		
			# Take the result bit array so far, 
			#  and or it with the value SQL returned, 
			#  bit shifted the number of lanes 
			bitArray |= selected << shift

		data.update({
		'IGN_Barcode_Returned':raw_barcode,
		'IGN_Destination_Returned': bitArray,	
		'IGN_GotData_Returned': True,
		'RouteCode_Returned':"NOIBN"
		})



	push_sequence(source_path, sequence_id, data)
	mongoupdate(data)
	log_event(1, data)



@async(name="NEReceiving-DumpData")
def dump_data(source_path, data):
	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
	
	mode = data.pop('mode', 2)
	
	i = 0
	while system.tag.read(parent_dest + '/' + 'IGN_GotData_Returned').value:
		sleep(CLEAR_WAIT_TIME)
		i += CLEAR_WAIT_TIME
		if i > FAILSAFE_TIMEOUT:
			system.util.getLogger('Handshake15').warn("Writeback payload: Took too long to see IGN_GotData_Returned clear for %s" % (source_path,))
			return
#			raise RuntimeError("Took too long to receive IGN_GotData_Returned clear for %s (with %r)" % (source_path, data))
	
	# if we DID have to wait, then wait just a moment longer to make sure the PLC
	# has time to catch up
	if i > 0:
		sleep(CLEAR_WAIT_TIME)
	
	tag_paths = []
	values = []
	for key,value in data.items():
		tag_paths.append(parent_dest + '/' + key)
		values.append(value)

	opc_fqv_paths = [tag_path + '.OpcItemPath' for tag_path in tag_paths]
	
	def write_block(qualified_values, tag_paths=tag_paths, values=values, ack_tag='IGN_GotData_Returned', data=data, mode=mode):
		opc_paths = []
		opc_values = []
		for qv, tag_path, value in zip(qualified_values, tag_paths, values):
			if tag_path.endswith('/' + ack_tag):
				ack_path = qv.value
				ack_value = value
			else:
				opc_paths.append(qv.value)
				opc_values.append(value)
		
		results = system.opc.writeValues('Ignition OPC-UA Server', opc_paths, opc_values)
		
		system.util.getLogger('FAILACK').trace('ACK: %s on %s with %r' % (parent_dest, ack_path, ack_value))
		ack_result = system.opc.writeValue('Ignition OPC-UA Server', ack_path, ack_value)
		
		data['Got_Time'] = datetime.now().isoformat()
		log_event(mode, data)

	system.tag.readAsync(opc_fqv_paths, write_block)
	

def push_sequence(source_path, sequence_id, data):
	#Uncomment this to prevent overwrites and throw an error on repeated sequence IDs
	#assert (sequence_id, source_path) not in ExtraGlobal, "Cache is backed up! Sequence ID already in cache: [%s:%s]" % (sequence_id, source_path)
	assert isinstance(data, dict), "Data object should be a dictionary here."

	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	
	# check if the sequence already exists and is (somehow) straggling
	if ExtraGlobal.get(sequence_id, source_path):
		system.util.getLogger('Handshake15').warn('Push sequence: Sequence [%d] already cached for %s: clearing to make room for next!' % (sequence_id, source_path) )
		try:
			del ExtraGlobal[sequence_id, source_path]
		except KeyError:
			pass # failsafe
	
	ExtraGlobal.stash(data, 
					  label=sequence_id, scope=source_path, 
					  lifespan=CACHE_LIFESPAN, 
					  callback=partial(flush_next_sequence, source_path, data)) 
					  
	system.util.getLogger('Handshake15').trace('>PUSH< [%d] %r' % (sequence_id, data))
#		'>PUSH< (#%d) for [%03d] %r >>> %r' % (len(ExtraGlobal.keys(scope=source_path)), sequence_id,
#						          list(ExtraGlobal.keys(scope=source_path)), data) )
					  
	flush_next_sequence(source_path)
	

def flush_next_sequence(source_path, data=None):
	# semaphore to prevent multithreaded interaction
	# but also return data to make sure the cache stays viable
	# (scoped to the 'handshake flushing' so that it can be checked independently)
	if ExtraGlobal.setdefault(source_path, 'Handshake15', False):
		return data
		
	# If no more sequences to flush, then signal to stop
	if not ExtraGlobal.keys(source_path):
		ExtraGlobal[source_path, 'Handshake15'] = False
		return

	# turn on semaphore to the current sequence getting worked on
	sequence_id = ExtraGlobal.keys(source_path)[0]

	ExtraGlobal[source_path, 'Handshake15'] = sequence_id
	
	try:
#		data = ExtraGlobal.pop(sequence_id, source_path)
		data = ExtraGlobal[sequence_id, source_path]
		del ExtraGlobal[sequence_id, source_path]
			
		# write results back
		dump_data(source_path, data)
	
		system.util.getLogger('Handshake15').trace('<POPD> [%d] %r' % (sequence_id, data))
	#		'<POPD> (#%d) for [%03d] %r >>> %r' % (len(ExtraGlobal.keys(scope=source_path)), sequence_id,
	#						          list(ExtraGlobal.keys(scope=source_path)), data) )
	except Exception, error:
		system.util.getLogger('Handshake15').warn('Flush: Error in completing handshake [%d] for %s: %r' % (sequence_id, source_path, error))
	
	# clear the semaphore and try again; when exhausted it'll just end
	ExtraGlobal[source_path, 'Handshake15'] = False
	
	# continue flushing if needed
	if ExtraGlobal.keys(source_path):
		flush_next_sequence(source_path, data)
		# don't return anything, since this is just continuing the flush process
		#return None

def mongoupdate(data):
	payload = {
			'IGN_Barcode_Returned': data['IGN_Barcode_Returned'],
			'IGN_Destination_Returned': data['IGN_Destination_Returned'],	
			'IGN_IndexID_Returned': data['IGN_IndexID_Returned'],
			'TimeStamp': datetime.utcnow(),
			'RouteCode_Returned': data['RouteCode_Returned']
			}
	db_access.insert_record(db_name, 'NE_Receiving_Induct', payload)
