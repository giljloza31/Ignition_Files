from shared.tools.global import ExtraGlobal
from shared.tools.thread import async
from shared.tools.meta import is_redundant_active
from functools import partial

from time import sleep
from random import random
from datetime import datetime
from pymongo import MongoClient

import re

import pymongo
user = "ignitionUser"
passw = "dsfasduwefnzy3848s#"
host = "txmongowcs1.mouser.lan"
replicaSet = "wcsRS1"
port = "27017"
mongodb = "ignition"
uri = 'mongodb://ignitionUser:dsfasduwefnzy3848s%23@txmongowcs1.mouser.lan:27017/ignition?tls=true&tlsAllowInvalidCertificates=true&replicaSet=wcsRS1&tlsCAFile=C%3A%5CMongo%5Cmouser-lan-root-ca.crt&authMechanism=DEFAULT&authSource=ignition'
client = MongoClient(uri)
db=client.ignition
SEPATATOR_PATTERN = ","



def cursorToList(cursor):
	listcursor = []
	for i in range(cursor.count()):
		listcursor.append(cursor.next())
	return listcursor

	
CACHE_LIFESPAN = 3.0 # seconds

CLEAR_WAIT_TIME  = 0.026
FAILSAFE_TIMEOUT = 6.0

ERROR_BARCODES = set(['', 'NOREAD'])


@async(name="VRS-GatherData")
def gather_data(source_path):
	'''
		Get the data that needs to be processed.
		
		This uses direct OPC reads on the spot, 
		  and writes the ACK as soon as it can.
	'''

	timestart = datetime.now().isoformat()
	
	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])

	# read the needed values in
	sequence_id, barcode = [
		qv.value for qv in 
		system.tag.readBlocking([
			parent_dest + '/' + 'IGN_IndexID_Sent',
			parent_dest + '/' + 'IGN_Barcode_Sent'
			])]

	system.tag.writeAsync([parent_dest + '/' + 'IGN_GetData_ACK'], [True])
	
	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
	system.tag.writeAsync([parent_dest + '/' + 'Get_Time'], [timestart])
	
	routing_barcodes = []
	if barcode == 'NOREAD':
		error_code = 'NOREAD'
		# query the route directly
		ibn = 'NOREAD'
		results = system.db.runPrepQuery("""
		select r.*
		from VRS_RouteTable_1 as r
		where r.Route_Code = ?
		""", [error_code],'SQLServer')
	elif SEPATATOR_PATTERN in barcode:
		
		barcodes = barcode.split(SEPATATOR_PATTERN)
		for i in range(len(barcodes)):
			check = barcodes[i]
			
			if re.match('(8)[0-9A-Z]{5}',check):
				if check not in routing_barcodes:
					routing_barcodes.append(check)
	
	else:
		if re.match('[0-9A-Z]{6}',barcode):
			routing_barcodes.append(barcode)
		

			
	if not routing_barcodes:
		results = None # clear the results
		error_code = 'NOIBN'	
		ibn = 'NOIBN'
		results = []		
			
	elif routing_barcodes:
		
		mongoSearch = db.inbound_receipt_info.find({"_id":{'$in':routing_barcodes}},{"_id":1,"zone":1}) 
		mongoResult = cursorToList(mongoSearch)
		mongoSearch.close()
		
		
					
		if not mongoResult:						
			error_code = 'NOIBN'								
			ibn = 'NOIBN'
			results = [] # clear the results													
		elif len(mongoResult)>1:
			error_code = 'MULTI'
			ibn = 'MULTI'	
			results = [] # clear the results
		elif len(mongoResult)==1:			
			dest = mongoResult[0]['zone']
			ibn = mongoResult[0]['_id']	
			results = system.db.runPrepQuery("""
				select r.*
				from VRS_RouteTable_1 as r
				where r.Route_Code = ?
				""", [dest],'SQLServer')
			if not results:
				error_code = 'NODEST'	
				
					
					
					
						
					
					
					
				
	if not results:
		# query the route directly
		results = system.db.runPrepQuery("""
		select r.*
		from VRS_RouteTable_1 as r
		where r.Route_Code = ?
		""", [error_code],'SQLServer')
	
	
			
	# grab the top entry
	row = results[0]
	
	# Start with no routes	
	bitArray = 0
	route_code = ''
	for selected,columnName in zip(row, results.columnNames):
		
		if columnName == 'Route_Code':
			route_code = selected
			continue
	
		if not columnName.startswith('Lane_'):
			continue
		
		# Get the second half on the underscore.
		# (rpartition splits on a thing, always retruning
		#  the left, split thing, and right of it)
		# And make it an int so we can shift on it
		# ... minus one because we are zero indexed, and lanes are one-indexed
		shift = int(columnName.rpartition('_')[2]) - 1
	
		# Take the result bit array so far, 
		#  and or it with the value SQL returned, 
		#  bit shifted the number of lanes 
		bitArray |= selected << shift
	
	timestop = datetime.now().isoformat()

	data = {
		
		'VRS_IGN_Barcode_Returned': ibn,
		'VRS_IGN_Destination_Returned': bitArray,	
		'VRS_IGN_IndexID_Returned': sequence_id,	
	
		
		'VRS_IGN_RouteCode_Returned': route_code,
		}
	
	
	# write results back
	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
	parent_dest += '/'
	
	system.tag.writeAsync(*zip(*[
#		(parent_dest + 'IGN_Barcode_Returned', ibn),	
#		(parent_dest + 'IGN_IndexID_Returned', sequence_id),			
#		(parent_dest + 'IGN_Destination_Returned', bitArray),	
#		(parent_dest + 'IGN_RouteCode_Returned', route_code),	
		(parent_dest + 'Got_Time', timestop),
#	
#		
	]))
	
	
		

	# delay for testing purposes
#	if random() < 0.8: # percent slowed
#		sleep(2*random()) # time in seconds (random is 0.0-1.0)
			
	push_sequence(source_path, sequence_id, data)


@async(name="Handshake12-DumpData")
def dump_data(source_path, data):
	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
	
	mode = data.pop('mode', 2)
	
	i = 0
	while system.tag.read(parent_dest + '/' + 'IGN_GotData_Returned').value:
		sleep(CLEAR_WAIT_TIME)
		i += CLEAR_WAIT_TIME
		if i > FAILSAFE_TIMEOUT:
			system.util.getLogger('Handshake12').warn("Writeback payload: Took too long to see IGN_GotData_Returned clear for %s" % (source_path,))
			return
#			raise RuntimeError("Took too long to receive IGN_GotData_Returned clear for %s (with %r)" % (source_path, data))
	
	# if we DID have to wait, then wait just a moment longer to make sure the PLC
	# has time to catch up
	if i > 0:
		sleep(CLEAR_WAIT_TIME)
	
	tag_paths = []
	values = []
	for key,value in data.items():
		tag_paths.append(parent_dest + '/' + key)
		values.append(value)

	opc_fqv_paths = [tag_path + '.OpcItemPath' for tag_path in tag_paths]
	
	def write_block(qualified_values, tag_paths=tag_paths, values=values, ack_tag='IGN_GotData_Returned', data=data, mode=mode):
		opc_paths = []
		opc_values = []
		for qv, tag_path, value in zip(qualified_values, tag_paths, values):
			if tag_path.endswith('/' + ack_tag):
				ack_path = qv.value
				ack_value = value
			else:
				opc_paths.append(qv.value)
				opc_values.append(value)
		
		results = system.opc.writeValues('Ignition OPC-UA Server', opc_paths, opc_values)
		
		

	system.tag.readAsync(opc_fqv_paths, write_block)
	

def push_sequence(source_path, sequence_id, data):
	#Uncomment this to prevent overwrites and throw an error on repeated sequence IDs
	#assert (sequence_id, source_path) not in ExtraGlobal, "Cache is backed up! Sequence ID already in cache: [%s:%s]" % (sequence_id, source_path)
	assert isinstance(data, dict), "Data object should be a dictionary here."

	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	
	# check if the sequence already exists and is (somehow) straggling
	if ExtraGlobal.get(sequence_id, source_path):
		system.util.getLogger('Handshake12').warn('Push sequence: Sequence [%d] already cached for %s: clearing to make room for next!' % (sequence_id, source_path) )
		try:
			del ExtraGlobal[sequence_id, source_path]
		except KeyError:
			pass # failsafe
	
	ExtraGlobal.stash(data, 
					  label=sequence_id, scope=source_path, 
					  lifespan=CACHE_LIFESPAN, 
					  callback=partial(flush_next_sequence, source_path, data)) 
					  
	system.util.getLogger('Handshake12').trace('>PUSH< [%d] %r' % (sequence_id, data))
#		'>PUSH< (#%d) for [%03d] %r >>> %r' % (len(ExtraGlobal.keys(scope=source_path)), sequence_id,
#						          list(ExtraGlobal.keys(scope=source_path)), data) )
					  
	flush_next_sequence(source_path)
	

def flush_next_sequence(source_path, data=None):
	# semaphore to prevent multithreaded interaction
	# but also return data to make sure the cache stays viable
	# (scoped to the 'handshake flushing' so that it can be checked independently)
	if ExtraGlobal.setdefault(source_path, 'Handshake12', False):
		return data
		
	# If no more sequences to flush, then signal to stop
	if not ExtraGlobal.keys(source_path):
		ExtraGlobal[source_path, 'Handshake12'] = False
		return

	# turn on semaphore to the current sequence getting worked on
	sequence_id = ExtraGlobal.keys(source_path)[0]

	ExtraGlobal[source_path, 'Handshake12'] = sequence_id
	
	try:
#		data = ExtraGlobal.pop(sequence_id, source_path)
		data = ExtraGlobal[sequence_id, source_path]
		del ExtraGlobal[sequence_id, source_path]
			
		# write results back
		dump_data(source_path, data)
	
		system.util.getLogger('Handshake12').trace('<POPD> [%d] %r' % (sequence_id, data))
	#		'<POPD> (#%d) for [%03d] %r >>> %r' % (len(ExtraGlobal.keys(scope=source_path)), sequence_id,
	#						          list(ExtraGlobal.keys(scope=source_path)), data) )
	except Exception, error:
		system.util.getLogger('Handshake12').warn('Flush: Error in completing handshake [%d] for %s: %r' % (sequence_id, source_path, error))
	
	# clear the semaphore and try again; when exhausted it'll just end
	ExtraGlobal[source_path, 'Handshake12'] = False
	
	# continue flushing if needed
	if ExtraGlobal.keys(source_path):
		flush_next_sequence(source_path, data)
		# don't return anything, since this is just continuing the flush process
		#return None
