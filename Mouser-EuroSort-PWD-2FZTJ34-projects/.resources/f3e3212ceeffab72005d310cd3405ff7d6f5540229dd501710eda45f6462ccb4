# shared.gitsync
# Centralized Git sync/commit/push logic for Ignition gateways.
# Triggered by:
# - Gateway Event Scripts -> Project -> Update (armed publish)
# - Tag Change scripts -> ForceSnapshotNow / ForcePushNow

import os
import system

# Tag provider is the customer name, and the folder structure is:
# [Mouser]Mouser/System/Config/GitSync/...
BASE = "[Mouser]Mouser/System/Config/GitSync/"

DEFAULT_SOURCE   = r"C:\Program Files\Inductive Automation\Ignition\data\projects"
DEFAULT_REPOROOT = r"C:\Ignition_Files"
DEFAULT_PS1      = r"C:\IgnitionTools\sync_commit.ps1"

def _log():
	return system.util.getLogger("GitSync")


def _read_tag(path, default=None):
	try:
		if val is None:
			return default
		return val
	except Exception as e:
		_log().error("Tag read failed: %s (%s)" % (path, e))
		return default


def _write_tag(path, value):
	try:
		system.tag.writeBlocking([path], [value])
	except Exception as e:
		_log().error("Tag write failed: %s=%r (%s)" % (path, value, e))


def _set_last_request(action):
	"""
	Update UI/status tags so you can see what last triggered the sync.
	"""
	_write_tag(BASE + "LastRequestTS", system.date.now())
	_write_tag(BASE + "LastRequestAction", str(action))


def _read_config():
	customer   = _read_tag(BASE + "Customer", "")
	systemName = _read_tag(BASE + "SystemName", "")
	note       = _read_tag(BASE + "CommitNote", "")
	pushOnPub  = bool(_read_tag(BASE + "PushOnPublish", False))

	# Optional overrides (tag-configurable paths)
	source   = _read_tag(BASE + "SourcePath", DEFAULT_SOURCE)
	reporoot = _read_tag(BASE + "RepoRoot", DEFAULT_REPOROOT)
	ps1      = _read_tag(BASE + "Ps1Path", DEFAULT_PS1)

	return customer, systemName, note, pushOnPub, source, reporoot, ps1


def validate(action="sync"):
	"""
	Validate configuration and environment. Returns True if OK, else False.
	Logs a clear message for each failing condition.
	"""
	log = _log()
	customer, systemName, note, pushOnPub, source, reporoot, ps1 = _read_config()

	ok = True

	# Required tags
	if not str(customer).strip():
		log.error("GitSync invalid: missing/blank tag %sCustomer" % BASE)
		ok = False
	if not str(systemName).strip():
		log.error("GitSync invalid: missing/blank tag %sSystemName" % BASE)
		ok = False

	# Paths
	if not os.path.isdir(source):
		log.error("GitSync invalid: SourcePath not found: %r" % source)
		ok = False
	if not os.path.isdir(reporoot):
		log.error("GitSync invalid: RepoRoot not found: %r" % reporoot)
		ok = False
	if not os.path.isfile(ps1):
		log.error("GitSync invalid: Ps1Path not found: %r" % ps1)
		ok = False

	# Git availability (service-safe check: verify git.exe exists at known locations)
	git_candidates = [
		r"C:\Program Files\Git\bin\git.exe",
		r"C:\Program Files\Git\cmd\git.exe"
	]
	if not any(os.path.isfile(g) for g in git_candidates):
		log.error("GitSync invalid: git.exe not found at expected locations: %r" % git_candidates)
		ok = False

	# Optional: warn if RepoRoot doesn't look like a repo yet (PS1 will init it)
	try:
		if os.path.isdir(reporoot) and not os.path.isdir(os.path.join(reporoot, ".git")):
			log.warn("GitSync: RepoRoot exists but has no .git yet (PS1 will git init): %r" % reporoot)
	except:
		pass

	if ok:
		log.info(
			"GitSync validate OK (action=%s) customer=%s system=%s source=%r reporoot=%r ps1=%r"
			% (action, customer, systemName, source, reporoot, ps1)
		)
	return ok


def _run_ps(action, push=False, forcePush=False, actor="gateway"):
	log = _log()

	customer, systemName, note, pushOnPub, source, reporoot, ps1 = _read_config()

	projectName = system.project.getProjectName()
	gatewayName = system.net.getHostName()

	cmd = [
		"powershell.exe",
		"-ExecutionPolicy", "Bypass",
		"-File", ps1,
		"-Source", str(source),
		"-RepoRoot", str(reporoot),
		"-Customer", str(customer),
		"-SystemName", str(systemName),
		"-GatewayName", str(gatewayName),
		"-ProjectName", str(projectName),
		"-Actor", str(actor),
		"-CommitNote", str(note or ""),
		"-Action", str(action),
	]

	if push:
		cmd.append("-Push")
	if forcePush:
		cmd.append("-ForcePush")

	log.info(
		"GitSync executing: action=%s push=%s forcePush=%s gateway=%s project=%s"
		% (action, push, forcePush, gatewayName, projectName)
	)
	log.info("GitSync launching PS1=%r RepoRoot=%r Source=%r" % (ps1, reporoot, source))

	def _do():
		try:
			system.util.execute(cmd)
		except Exception as e:
			log.error("GitSync PowerShell execution failed (%s). cmd=%r" % (e, cmd))

	system.util.invokeAsynchronous(_do)


def handle_publish_update():
	"""
	Called from Gateway Event Script: Project -> Update.
	Only acts when ArmCommitOnNextPublish is True, then resets it.
	"""
	if not validate(action="publish"):
		return

	armed = bool(_read_tag(BASE + "ArmCommitOnNextPublish", False))
	if not armed:
		return

	# Reset immediately to avoid double commits if update event fires multiple times
	_write_tag(BASE + "ArmCommitOnNextPublish", False)
# shared.gitsync
# Centralized Git sync/commit/push logic for Ignition gateways.
# Triggered by:
# - Gateway Event Scripts -> Project -> Update (armed publish)
# - Tag Change scripts -> ForceSnapshotNow / ForcePushNow

import os
import system

# Tag provider is the customer name, and the folder structure is:
# [Mouser]Mouser/System/Config/GitSync/...
BASE = "[Mouser]Mouser/System/Config/GitSync/"

DEFAULT_SOURCE   = r"C:\Program Files\Inductive Automation\Ignition\data\projects"
DEFAULT_REPOROOT = r"C:\Ignition_Files"
DEFAULT_PS1      = r"C:\IgnitionTools\sync_commit.ps1"

def _log():
	return system.util.getLogger("GitSync")


def _read_tag(path, default=None):
	try:
		val = system.tag.readBlocking([path])[0].value
		if val is None:
			return default
		return val
	except Exception as e:
		_log().error("Tag read failed: %s (%s)" % (path, e))
		return default


def _write_tag(path, value):
	try:
		system.tag.writeBlocking([path], [value])
	except Exception as e:
		_log().error("Tag write failed: %s=%r (%s)" % (path, value, e))


def _set_last_request(action):
	"""
	Update UI/status tags so you can see what last triggered the sync.
	"""
	_write_tag(BASE + "LastRequestTS", system.date.now())
	_write_tag(BASE + "LastRequestAction", str(action))


def _read_config():
	customer   = _read_tag(BASE + "Customer", "")
	systemName = _read_tag(BASE + "SystemName", "")
	note       = _read_tag(BASE + "CommitNote", "")
	pushOnPub  = bool(_read_tag(BASE + "PushOnPublish", False))

	# Optional overrides (tag-configurable paths)
	source   = _read_tag(BASE + "SourcePath", DEFAULT_SOURCE)
	reporoot = _read_tag(BASE + "RepoRoot", DEFAULT_REPOROOT)
	ps1      = _read_tag(BASE + "Ps1Path", DEFAULT_PS1)

	# NEW: GitHub PAT (used by PS1 for non-interactive push)
	gitToken = _read_tag(BASE + "GitToken", "")

	return customer, systemName, note, pushOnPub, source, reporoot, ps1, gitToken


def validate(action="sync"):
	"""
	Validate configuration and environment. Returns True if OK, else False.
	Logs a clear message for each failing condition.
	"""
	log = _log()
	customer, systemName, note, pushOnPub, source, reporoot, ps1, gitToken = _read_config()

	ok = True

	# Required tags
	if not str(customer).strip():
		log.error("GitSync invalid: missing/blank tag %sCustomer" % BASE)
		ok = False
	if not str(systemName).strip():
		log.error("GitSync invalid: missing/blank tag %sSystemName" % BASE)
		ok = False

	# Paths
	if not os.path.isdir(source):
		log.error("GitSync invalid: SourcePath not found: %r" % source)
		ok = False
	if not os.path.isdir(reporoot):
		log.error("GitSync invalid: RepoRoot not found: %r" % reporoot)
		ok = False
	if not os.path.isfile(ps1):
		log.error("GitSync invalid: Ps1Path not found: %r" % ps1)
		ok = False

	# Git availability (service-safe check: verify git.exe exists at known locations)
	git_candidates = [
		r"C:\Program Files\Git\bin\git.exe",
		r"C:\Program Files\Git\cmd\git.exe"
	]
	if not any(os.path.isfile(g) for g in git_candidates):
		log.error("GitSync invalid: git.exe not found at expected locations: %r" % git_candidates)
		ok = False

	# Optional: warn if RepoRoot doesn't look like a repo yet (PS1 will init it)
	try:
		if os.path.isdir(reporoot) and not os.path.isdir(os.path.join(reporoot, ".git")):
			log.warn("GitSync: RepoRoot exists but has no .git yet (PS1 will git init): %r" % reporoot)
	except:
		pass

	# If we expect push, token should exist (we warn, PS1 will hard-fail if push requested without token)
	if action in ("snapshot", "force-push", "publish", "force") and pushOnPub:
		if not str(gitToken).strip():
			log.warn("GitSync: GitToken is blank; pushes may fail/hang unless PS1 is using PAT auth.")

	if ok:
		log.info(
			"GitSync validate OK (action=%s) customer=%s system=%s source=%r reporoot=%r ps1=%r"
			% (action, customer, systemName, source, reporoot, ps1)
		)
	return ok


def _run_ps(action, push=False, forcePush=False, actor="gateway"):
	log = _log()

	customer, systemName, note, pushOnPub, source, reporoot, ps1, gitToken = _read_config()

	projectName = system.project.getProjectName()
	gatewayName = system.net.getHostName()

	cmd = [
		"powershell.exe",
		"-ExecutionPolicy", "Bypass",
		"-File", ps1,
		"-Source", str(source),
		"-RepoRoot", str(reporoot),
		"-Customer", str(customer),
		"-SystemName", str(systemName),
		"-GatewayName", str(gatewayName),
		"-ProjectName", str(projectName),
		"-Actor", str(actor),
		"-CommitNote", str(note or ""),
		"-Action", str(action),
	]

	# NEW: pass PAT to PS1 so push is non-interactive
	cmd += ["-GitToken", str(gitToken or "")]

	if push:
		cmd.append("-Push")
	if forcePush:
		cmd.append("-ForcePush")

	log.info(
		"GitSync executing: action=%s push=%s forcePush=%s gateway=%s project=%s"
		% (action, push, forcePush, gatewayName, projectName)
	)
	log.info("GitSync launching PS1=%r RepoRoot=%r Source=%r" % (ps1, reporoot, source))

	def _do():
		try:
			system.util.execute(cmd)
		except Exception as e:
			log.error("GitSync PowerShell execution failed (%s). cmd=%r" % (e, cmd))

	system.util.invokeAsynchronous(_do)


def handle_publish_update():
	"""
	Called from Gateway Event Script: Project -> Update.
	Only acts when ArmCommitOnNextPublish is True, then resets it.
	"""
	if not validate(action="publish"):
		return

	armed = bool(_read_tag(BASE + "ArmCommitOnNextPublish", False))
	if not armed:
		return

	# Reset immediately to avoid double commits if update event fires multiple times
	_write_tag(BASE + "ArmCommitOnNextPublish", False)

	pushOnPublish = bool(_read_tag(BASE + "PushOnPublish", False))

	_set_last_request("publish")
	_run_ps(action="publish", push=pushOnPublish, forcePush=False, actor="gateway")


def handle_force_trigger(trigger_tag_path):
	"""
	Called by Tag Change scripts (ForceSnapshotNow / ForcePushNow).
	Always resets the triggering tag back to False.
	"""
	def _reset_trigger():
		try:
			system.tag.writeBlocking([trigger_tag_path], [False])
		except Exception as e:
			_log().error("Failed to reset trigger tag %r (%s)" % (trigger_tag_path, e))

	tp = str(trigger_tag_path)
	is_force_push = tp.endswith("ForcePushNow")

	action = "force-push" if is_force_push else "snapshot"

	_set_last_request(action)

	if not validate(action="force"):
		_reset_trigger()
		return

	# Force actions push by default (snapshot + force-push both push)
	_run_ps(action=action, push=True, forcePush=is_force_push, actor="gateway")

	_reset_trigger()
	pushOnPublish = bool(_read_tag(BASE + "PushOnPublish", False))

	_set_last_request("publish")
	_run_ps(action="publish", push=pushOnPublish, forcePush=False, actor="gateway")


def handle_force_trigger(trigger_tag_path):
	"""
	Called by Tag Change scripts (ForceSnapshotNow / ForcePushNow).
	Always resets the triggering tag back to False.
	"""

	def _reset_trigger():
		try:
			# reset the exact triggering tag path (already fully-qualified)
			system.tag.writeBlocking([trigger_tag_path], [False])
		except Exception as e:
			_log().error("Failed to reset trigger tag %r (%s)" % (trigger_tag_path, e))

	tp = str(trigger_tag_path)
	is_force_push = tp.endswith("ForcePushNow")

	action = "force-push" if is_force_push else "snapshot"

	_set_last_request(action)

	if not validate(action="force"):
		_reset_trigger()
		return


	# Force actions push by default (snapshot + force-push both push)
	_run_ps(action=action, push=True, forcePush=is_force_push, actor="gateway")

	_reset_trigger()