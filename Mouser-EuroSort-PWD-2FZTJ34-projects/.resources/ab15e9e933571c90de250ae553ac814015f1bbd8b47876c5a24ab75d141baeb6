from shared.tools.global import ExtraGlobal
from shared.tools.thread import async
from shared.tools.meta import is_redundant_active
from functools import partial
	
from time import sleep
from random import random
from datetime import datetime
from time import sleep
from random import random
from datetime import datetime

from java.util import Date
import re

from pymongo import MongoClient
from pymongo import *
	
#MongoDB Connection URI
uri = 'mongodb://ignitionUser:dsfasduwefnzy3848s%23@txmongowcs1.mouser.lan:27017/ignition?tls=true&tlsAllowInvalidCertificates=true&replicaSet=wcsRS1&tlsCAFile=C%3A%5CMongo%5Cmouser-lan-root-ca.crt&authMechanism=DEFAULT&authSource=ignition'
#uri = 'mongodb://localhost:27017/'
#MongoDB Database connection format
client = MongoClient(uri,connectTimeoutMS=5000, socketTimeoutMS=5000)
db=client.ignition
#db=client.PWD

#API endpoint for marriage of LPN to IBN
BAL_ENDPOINT = 'http://wcs01:8085/ws/v1/lpns/%s'

CACHE_LIFESPAN = 3.0 # seconds
LABEL_PRINT_TIMEOUT = 3.0 # seconds

# https://regex101.com/r/OJMs5F/1
CODE_SEP_PATTERN = re.compile(u'[,]')
STR_SEP_PATTERN = re.compile(u'[;]')

barcodesErrorList = [
	 '^(NO_BARCODE)$',
	 '^(NOREAD)$'
	]

dimErrorList = [
    '(NODIM_BOX_SIDE_BY_SIDE)$',
    '(NODIM_BOX_SIDES_TOO_NOISY)$',
    '(NODIM_BOX_POINT_BORDER_DIST)$',
    '(NODIM_BOX_PEAK_VS_BORDER)$'
	]

IBN_PATTERN = [
        '^[0-9]{1}[0-9A-Z]{5}$'
        ]
LPN_PATTERN = [
        '^(M)[0-9A-Z]{11}$',
        '^(M)[0-9A-Z]{7}$',
        '^(0)[0-9A-Z]{7}$',
        '^(I4)[0-9A-Z]{6}$',
        '^(I5)[0-9A-Z]{6}$',
        '^(R)[0-9A-Z]{11}$',
        '^(T)[0-9A-Z]{11}$',
        '^(P)[0-9A-Z]{11}$',
        '^(BA)[0-9A-Z]{6}$'
	]

barcodeError = "(" + ")|(".join(barcodesErrorList) + ")"
dimError = "(" + ")|(".join(dimErrorList) + ")"
ibnList = "(" + ")|(".join(IBN_PATTERN) + ")"
lpnList = "(" + ")|(".join(LPN_PATTERN) + ")"



class RoutingException(Exception):
	pass

class Multi(RoutingException): pass

class ImproperFormat(RoutingException): pass

class NOREAD(RoutingException): pass

class NOCODE(RoutingException): pass

class mongoUpdate(RoutingException): pass


def cursorToList(cursor):
	listcursor = []
	for i in range(cursor.count()):
		listcursor.append(cursor.next())
		
	return listcursor
	
def BAL_lookup_and_decode(raw_barcode,data):
	lbn_Barcodes = []
	ibn_Barcodes = []
	scanData = []
	pagecount = 0
	
	#Check for proper str format
	#354;    17.17; 16.4,11.4,13.8;in;READY;; 651-2905289,2022-03-02,3010385297,074080892,9995827988,1669EB
	
	if STR_SEP_PATTERN in raw_barcode:
	
		scanData = raw_barcode.split(STR_SEP_PATTERN)
		
	else:
		scanData.append(raw_barcode)
		
	if len(scanData) != 7:
		raise ImproperFormat(raw_barcode,data)

	
	BAL_data = {
		"seq":scanData[0],
		"ibn":scanData[6],
		"weight":scanData[1],
		"DimensionString":scanData[2]
	}


	rawIBN = set(BAL_data['ibn'].split(',')) # set deduplicates lists
	ibn_list = list(rawIBN)
		

	dimsIn = BAL_data['DimensionString'].split(',')


	for token in ibn_list:
		checkBarcode = token.strip()
		if re.match(barcodeError,checkBarcode):
			raise NOREAD(data)
		elif re.match(lpnList,checkBarcode):
			if checkBarcode not in lbn_Barcodes:
				lbn_Barcodes.append(checkBarcode)
		elif re.match(ibnList,checkBarcode):
			# 6 charaters only
			if checkBarcode not in ibn_Barcodes:
				ibn_Barcodes.append(checkBarcode)



	data.update({
		"ibn":BAL_data['ibn'],
		"weight": int(float(BAL_data['weight'])*100),
		"height": int(float(dimsIn[2])*1000),
		"length": int(float(dimsIn[0])*1000),
		"width":  int(float(dimsIn[1])*1000)
	})

	system.util.getLogger('BAL_Testing').trace('%s'%(data))

	
	
	filter={
	   "_id":{'$in':ibn_Barcodes}
	}
	project={
	    '_id': 1, 
	   'bulk_single_flag': 1, 
	   'catchbox_flag': 1,
	   'va_flag': 1
	}
	
	
	IBNQuery = db.outbound_scan_sort_ibn.find(
			filter=filter,
			projection=project
			)

	IBNresults = cursorToList(IBNQuery)
	IBNQuery.close()	
	IBNcount = len(IBNresults)


	LPNresults = []
	LPN_List = []
	filter={
	   '$and':[{'lpn':{'$in':lbn_Barcodes}},{'placement':'outside'}]
	}
	project={
		'_id':0,
	   'lpn': 1, 
	   'page_count': 1,
	   'placement':1
	}
	
	LPNQuery = db.ipack_docs_info.find(
			filter=filter,
			projection=project
			)
		
	

	LPNresults = cursorToList(LPNQuery)
	
	LPNcount = len(LPNresults)
	LPNQuery.close()
	
	BAresults = []
	filter={
	   "_id":{'$in':lbn_Barcodes}
	}

	
	BAQuery = db.bulk_automation_packages.find(
			filter=filter
			)
		
	

	BAresults = cursorToList(BAQuery)
	
	BAcount = len(BAresults)
	BAQuery.close()
	

	if IBNcount > 1 and LPNcount > 1:

		raise Multi(data)
	
		
	if BAcount == 1:
		if data['IGN_BAL_Available']==True:
			if data['length'] >= data['Max_Allowed_Sized'] or data['width'] >= data['Max_Allowed_Sized']:
				destination = (1<<(2-1))
				route = 'Bulk Shipping'
				
						
			else:
				destination = (1<<(1-1))
				route = 'Bulk Automated'		
		
		data.update({
			'IGN_Destination_Returned':destination,
			'IGN_Route_Returned':route,
			'IGN_Barcode_Returned':BAresults[0]['_id'],
			'IGN_PageCount_Returned':BAresults[0]['page_count'],
			'IGN_LPN_Returned':BAresults[0]['_id'],
			'IGN_Marriage_Result_Returned': 0,
			'bulkResults':False,
			'catchResults':False,
			'vaResults':False
			})
		raise mongoUpdate(data)
	
	
	
	
	elif LPNcount >= 1:

		for i in range(LPNcount):
			if LPNresults[i]['lpn'] not in LPN_List:
				LPN_List.append(LPNresults[i]['lpn'])
		
		LPN_ListCount = len(LPN_List)
		
		if LPN_ListCount == 1:
			for i in range(LPN_ListCount):
				 pagecount += LPNresults[i]['page_count']

		data.update({
			'IGN_PageCount_Returned':pagecount,
			'bulkResults':True,
			'catchResults':False,
			'vaResults':False
			})
		system.util.getLogger('BAL LPN query').trace('data returned is %s'%(data))
	
		
		if LPN_ListCount == 1:
			if data['IGN_BAL_Available']==True:
				if data['length'] >= data['Max_Allowed_Sized'] or data['width'] >= data['Max_Allowed_Sized']:
					destination = (1<<(2-1))
					route = 'Bulk Shipping'
					
							
				else:
					destination = (1<<(1-1))
					route = 'Bulk Automated'

			
			
	
			data.update({
			'IGN_Destination_Returned':destination,
			'IGN_Route_Returned':route,
			'IGN_Barcode_Returned':LPNresults[0]['lpn'],
			'IGN_PageCount_Returned':pagecount,
			'IGN_LPN_Returned':LPNresults[0]['lpn'],
			'IGN_Marriage_Result_Returned': 0,
			'bulkResults':False,
			'catchResults':False,
			'vaResults':False
			})
		
	



	elif IBNcount == 1:
		data.update({
		'bulkResults':IBNresults[0]['bulk_single_flag'],
		'catchResults':IBNresults[0]['catchbox_flag'],
		'vaResults':IBNresults[0]['va_flag']

		})		
			
		if data['catchResults'] or data['vaResults']:
			
			data.update({
				'IGN_Destination_Returned':(1<<(3-1)),
				'IGN_Barcode_Returned':IBNresults[0]["_id"],
				'IGN_Route_Returned':'CatchBox',
				'IGN_LPN_Returned':IBNresults[0]["_id"],
				'IGN_PageCount_Returned':0,
				'IGN_Marriage_Result_Returned': 0
				
				})

		
		elif data['bulkResults']==True:
			if data['length'] >=  data['Max_Allowed_Sized'] or data['width'] >= data['Max_Allowed_Sized']:

				data.update({
				'IGN_Destination_Returned':(1<<(2-1)),
				'IGN_Barcode_Returned':IBNresults[0]["_id"],
				'IGN_Route_Returned':'Bulk Shipping',
				'IGN_LPN_Returned':IBNresults[0]["_id"],
				'IGN_LPN_Returned':'',
				'IGN_Marriage_Result_Returned': 0,
				'IGN_PageCount_Returned':0,
				
				})

			else:

				if data['IGN_BAL_Available']==True:
					destination = (1<<(1-1))
				else:
					destination = (1<<(2-1))	
				
				
	
				data.update({
				'IGN_Destination_Returned':destination,
				'IGN_Barcode_Returned':IBNresults[0]["_id"],
				'IGN_PageCount_Returned':0,
				'IGN_Route_Returned':'Bulk Automated',
				'IGN_LPN_Returned':'',
				'IGN_Marriage_Result_Returned': 1
				})			


			
				ExtraGlobal.stash(data,
					label=data['IGN_Barcode_Returned'], 
					scope='Marry-IBN-LPN2',
					lifespan=20.0,
					)
		elif data['bulkResults'] == False:
			data.update({
				'IGN_Destination_Returned':(1<<(2-1)),
				'IGN_Barcode_Returned':IBNresults[0]["_id"],
				'IGN_PageCount_Returned':0,
				'IGN_Route_Returned':'Bulk Shipping',
				'IGN_LPN_Returned':IBNresults[0]["_id"],
				'IGN_Marriage_Result_Returned': 0
				})		
						

		
	
	elif IBNcount == 0 and LPNcount == 0:

		raise NOCODE(data)


	return data		
					

@async(name="BALPSI-Routing-GatherData")
def BAL_PSI_gather_data(source_path):
	timeStart = system.date.now()
	GET_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	GOT_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
		
	sequence_id, raw_barcode, BAL_LPN, avail, Set_Dim = [

		qv.value for qv in 
		system.tag.readBlocking([
			GET_parent_dest + '/' + 'IGN_IndexID_Sent',
			GET_parent_dest + '/' + 'BAL1000_SCAN_TUNNEL',
			GET_parent_dest + '/' + 'Sent_To_Printer',
			GET_parent_dest + '/' + 'Bulk_Automated_Avail',
			GET_parent_dest + '/' + 'Set_Dim'
		])]

	#Automatically start time		
	system.tag.writeAsync(*zip(*[
			
		(GOT_parent_dest + '/' + 'Get_Time', timeStart),
	
		]))

	max_dim = int(Set_Dim) * 1000
	

	data = {

		'IGN_IndexID_Returned':sequence_id,
		'Max_Allowed_Sized':max_dim,
		'IGN_Last_LPN':BAL_LPN,
		'IGN_BAL_Available':avail


	}

	

	try:
		try:

			data.update(BAL_lookup_and_decode(raw_barcode,data))

		except Exception, error:
			system.util.getLogger('BAL Dimensioner Error').trace(repr(error))
			raise error


	except mongoUpdate:

	
			
		db.bulk_automation_packages.update({'_id':data['IGN_Barcode_Returned']},{'$set':{'weight':data['weight'],"length": data['length'],"width":  data['width'],"height": data['height'],'date_time':datetime.utcnow()}})
	
	
	
	except Multi:

		data.update({
		'IGN_Destination_Returned':(1<<(2-1)),
		'IGN_Route_Returned':'Bulk Shipping',
		'IGN_Barcode_Returned':raw_barcode,
		'IGN_PageCount_Returned':0,
		'IGN_LPN_Returned':raw_barcode,
		'IGN_Marriage_Result_Returned': 0,
		'bulkResults':False,
		'catchResults':False,
		'vaResults':False

		
		})



	except ImproperFormat:
		
		data.update({
		'IGN_Destination_Returned':(1<<(2-1)),
		'IGN_Route_Returned':'Bulk Shipping',
		'IGN_Barcode_Returned':raw_barcode,
		'IGN_PageCount_Returned':0,
		'IGN_LPN_Returned':raw_barcode,
		'IGN_Marriage_Result_Returned': 0,
		'bulkResults':False,
		'catchResults':False,
		'vaResults':False

		
		})

	except NOREAD:

		data.update({
		'IGN_Destination_Returned':(1<<(2-1)),
		'IGN_Route_Returned':'Bulk Shipping',
		'IGN_Barcode_Returned':raw_barcode,
		'IGN_PageCount_Returned':0,
		'IGN_LPN_Returned':raw_barcode,
		'IGN_Marriage_Result_Returned': 0,
		'bulkResults':False,
		'catchResults':False,
		'vaResults':False

		
		})


	except NOCODE:
		codeReturned = 'Nocode'
		data.update({
		'IGN_Destination_Returned':(1<<(2-1)),
		'IGN_Route_Returned':'Bulk Shipping',
		'IGN_Barcode_Returned':codeReturned,
		'IGN_PageCount_Returned':0,
		'IGN_LPN_Returned':codeReturned,
		'IGN_Marriage_Result_Returned': 0,
		'bulkResults':False,
		'catchResults':False,
		'vaResults':False

		
		})


	except:
		
		data.update({
		'IGN_Destination_Returned':(1<<(2-1)),
		'IGN_Route_Returned':'Error',
		'IGN_Barcode_Returned':raw_barcode,
		'IGN_PageCount_Returned':0,
		'IGN_LPN_Returned':raw_barcode,
		'IGN_Marriage_Result_Returned': 0,
		'bulkResults':False,
		'catchResults':False,
		'vaResults':False,
		"weight": 0,
		"height": 0,
		"length": 0,
		"width":  0
		
		})

	#system.util.getLogger('BAL_Testing').trace('%s destination'%(data['IGN_Destination_Returned']))
	push_sequence(source_path, sequence_id, data)

	if data['IGN_Destination_Returned'] == 1 and data['IGN_Marriage_Result_Returned'] == 0:
		STEpayload = {
			'IndexId' : data['IGN_IndexID_Returned'],
			'Barcode': data['IGN_Barcode_Returned'],
			'timestamp': system.date.now()
		}
		BAL_Transfer(STEpayload)

	if data['IGN_Marriage_Result_Returned'] == 0:
		Mongopayload = {

		'_id': data['IGN_Barcode_Returned'],
		"weight":  data['weight'],
		"length": data['length'],
		"width":  data['width'],
		"height": data['height'],
		'destination':data['IGN_Destination_Returned'],
		'page_count':data['IGN_PageCount_Returned'],
		'shipped':False,
		'shipped_date_time': datetime.utcnow(),
		'date_time': datetime.utcnow(),
		'wcs_error':'',	
		'wcs_error_date_time':datetime.utcnow(),
		'barcode':data['IGN_Barcode_Returned'],
		'marriage_status': 0,
		'marrige_complete':False,
		'marriage_required':data['IGN_Marriage_Result_Returned']

		}
	
	
		error = ['NOIBN','','NOCODE','Multi']
	
		
		if Mongopayload['_id'] not in error:
	
			filter={
				  "_id":Mongopayload['_id']
				}
			
			sort=list({
				    'date_time': -1,"_id": -1
				}.items())
			limit=1
			
			MongoQuery = db.bulk_automation_packages.find(
				filter=filter
				)
								
							
						
			Mongoresult = cursorToList(MongoQuery)		
			MongoQuery.close()	
		
			Mongocount = len(Mongoresult)
			
			
		
			if Mongocount == 0:
				db.bulk_automation_packages.insert(Mongopayload)
				#setTable = createDataset(inductTable,Mongopayload)
			



def BAL_Transfer(payload):
	
		query = """	
			INSERT INTO Valid_BAL_Transfers (
			IndexId,
			Barcode,
			Married,
			MarriedString,
			timestamp
			) 
			VALUES (?,?,?,?,?)
			"""
		
		system.db.runPrepUpdate(query, [
				payload['IndexId'],
				payload['Barcode'],
				0,
				'',
				payload['timestamp'],	
			], 'SQLServer')	

@async(name='Pending-Label-Marry')
def marry_ibn_lpn(BAL_LPN, ibn):
	"""An IBN was routed - wait a bit, and then this will see if an LPN has been scanned. 
	If so, marry them!
	
	If no matching entry is cached, then we assume it failed and throw an error to the Ignition wrapper
	console. Likewise, if a cache entry times out, then we throw an error for that on timeout.
	"""

	pagecount = 0
	
	if ibn is None:
		# assume it's already been stashed, or fail
		try:
			data = ExtraGlobal.pop(label=ibn, scope='Marry-IBN-LPN2')
		except KeyError:
			system.util.getLogger('BAL_Labels').error('No matching cached ibns found for ibn %r' % (ibn))
			return

	
	# combine the LPN with the IBN
	endpoint = BAL_ENDPOINT % BAL_LPN

	api_payload = {"ibns": [ibn]}
	api_payload_json_string = system.util.jsonEncode(api_payload) # STRING

	system.util.getLogger('BAL_Labels').trace('REST call to %r payload: %r' % (endpoint, api_payload_json_string))

	response = system.net.httpPost(
		url=endpoint, 
		contentType='application/json',
		postData=api_payload_json_string,
		throwOnError = False,
		)
	

	result = system.util.jsonDecode(response)	
	
	
	marrige_complete = True

	LPN_List = []
	LPNresults = []
	
	filter={
		'$and':[{'lpn':BAL_LPN},{'placement':'outside'}]
	}
	project={
		'_id':0,
		'lpn': 1, 
		'page_count': 1,
		'placement':1
	}
	
	
	
	LPNQuery = db.ipack_docs_info.find(
		filter=filter,
		projection=project
		
		)
						
							
						
	LPNresults = cursorToList(LPNQuery)		
	LPNQuery.close()				
	LPNcount = len(LPNresults)


	for i in range(LPNcount):
		if LPNresults[i]['lpn'] not in LPN_List:
			LPN_List.append(LPNresults[i]['lpn'])
		
	LPN_ListCount = len(LPN_List)

	if LPN_ListCount == 1:
		pagecount = 0
			
		for i in range(LPNcount):
			 pagecount += LPNresults[i]['page_count']

		Mongopayload = {
	
		'_id': BAL_LPN,
		"weight":  data['weight'],
		"length": data['length'],
		"width":  data['width'],
		"height": data['height'],
		'destination':data['IGN_Destination_Returned'],
		'page_count':pagecount,
		'shipped':False,
		'shipped_date_time': datetime.utcnow(),
		'date_time': datetime.utcnow(),
		'wcs_error':'',	
		'wcs_error_date_time':datetime.utcnow(),
		'barcode':ibn,
		'marriage_status': 0,
		'marrige_complete':False,
		'marriage_required':data['IGN_Marriage_Result_Returned']
	
		}
	else:
		Mongopayload = {
	
		'_id': BAL_LPN,
		"weight":  data['weight'],
		"length": data['length'],
		"width":  data['width'],
		"height": data['height'],
		'destination':data['IGN_Destination_Returned'],
		'page_count':0,
		'shipped':False,
		'shipped_date_time': datetime.utcnow(),
		'date_time': datetime.utcnow(),
		'wcs_error':'',	
		'wcs_error_date_time':datetime.utcnow(),
		'barcode':ibn,
		'marriage_status': 0,
		'marrige_complete':False,
		'marriage_required':data['IGN_Marriage_Result_Returned']
		}
		


	db.bulk_automation_packages.insert(Mongopayload)
	query = """	
				UPDATE Valid_BAL_Transfers 
				SET Married = ?,
				MarriedString = ?
				WHERE Barcode = ?
				"""
			
	system.db.runPrepUpdate(query, [
					1,
					ibn,
					BAL_LPN	
				], 'SQLServer')	


	system.util.getLogger('BAL_Labels').debug('Matched: LPN %r and IBNs %r' % (BAL_LPN, ibns))
	

	

@async(name="BAL-DumpData")
def dump_data(source_path, data):
	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
	parent_dest += '/'
	mode = data.pop('mode', 2)

	
	tag_paths = []
	values = []
	for key,value in data.items():
		tag_paths.append(parent_dest + '/' + key)
		values.append(value)

	opc_fqv_paths = [tag_path + '.OpcItemPath' for tag_path in tag_paths]
	
	def write_block(qualified_values, tag_paths=tag_paths, values=values, ack_tag='IGN_GotData_Returned', data=data, mode=mode):
		opc_paths = []
		opc_values = []
		for qv, tag_path, value in zip(qualified_values, tag_paths, values):

			if tag_path.endswith('/' + ack_tag):
				ack_path = qv.value
				ack_value = value
			elif qv.value: # good opc path found
				opc_paths.append(qv.value)
				opc_values.append(value)
				
		results = system.opc.writeValues('Ignition OPC-UA Server', opc_paths, opc_values)
		
		system.util.getLogger('BAL_Routing').trace('[%05d]  OPC: %r >>> %r (>>> QUAL: %r)' % (
			Date().getTime() % 100000, opc_paths, opc_values, [x for x in results]))
		

	system.tag.readAsync(opc_fqv_paths, write_block)
	#system.tag.writeBlocking('[default]BAL/BAL1000/Got_Data/IGN_Route_Returned', data['IGN_Route_Returned'])

	
def push_sequence(source_path, sequence_id, data):
	#Uncomment this to prevent overwrites and throw an error on repeated sequence IDs
	#assert (sequence_id, source_path) not in ExtraGlobal, "Cache is backed up! Sequence ID already in cache: [%s:%s]" % (sequence_id, source_path)
	assert isinstance(data, dict), "Data object should be a dictionary here."

	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	
	# check if the sequence already exists and is (somehow) straggling
	if ExtraGlobal.get(sequence_id, source_path):
		system.util.getLogger('Handshake22').warn('Push sequence: Sequence [%d] already cached for %s: clearing to make room for next!' % (sequence_id, source_path) )
		try:
			del ExtraGlobal[sequence_id, source_path]
		except KeyError:
			pass # failsafe
	
	ExtraGlobal.stash(data, 
					  label=sequence_id, scope=source_path, 
					  lifespan=CACHE_LIFESPAN, 
					  callback=partial(flush_next_sequence, source_path, data)) 
					  
	system.util.getLogger('Handshake22').trace('>PUSH< [%d] %r' % (sequence_id, data))
#		'>PUSH< (#%d) for [%03d] %r >>> %r' % (len(ExtraGlobal.keys(scope=source_path)), sequence_id,
#						          list(ExtraGlobal.keys(scope=source_path)), data) )
					  
	flush_next_sequence(source_path)
		
	
def flush_next_sequence(source_path, data=None):
	# semaphore to prevent multithreaded interaction
	# but also return data to make sure the cache stays viable
	# (scoped to the 'handshake flushing' so that it can be checked independently)
	if ExtraGlobal.setdefault(source_path, 'Handshake22', False):
		return data
		
	# If no more sequences to flush, then signal to stop
	if not ExtraGlobal.keys(source_path):
		ExtraGlobal[source_path, 'Handshake22'] = False
		return

	# turn on semaphore to the current sequence getting worked on
	sequence_id = ExtraGlobal.keys(source_path)[0]

	ExtraGlobal[source_path, 'Handshake22'] = sequence_id
	
	try:
#		data = ExtraGlobal.pop(sequence_id, source_path)
		data = ExtraGlobal[sequence_id, source_path]
		del ExtraGlobal[sequence_id, source_path]
			
		# write results back
		dump_data(source_path, data)
	
		system.util.getLogger('Handshake22').trace('<POPD> [%d] %r' % (sequence_id, data))
	#		'<POPD> (#%d) for [%03d] %r >>> %r' % (len(ExtraGlobal.keys(scope=source_path)), sequence_id,
	#						          list(ExtraGlobal.keys(scope=source_path)), data) )
	except Exception, error:
		system.util.getLogger('Handshake22').warn('Flush: Error in completing handshake [%d] for %s: %r' % (sequence_id, source_path, error))
	
	# clear the semaphore and try again; when exhausted it'll just end
	ExtraGlobal[source_path, 'Handshake22'] = False
	
	# continue flushing if needed
	if ExtraGlobal.keys(source_path):
		flush_next_sequence(source_path, data)
		# don't return anything, since this is just continuing the flush process
		#return None	