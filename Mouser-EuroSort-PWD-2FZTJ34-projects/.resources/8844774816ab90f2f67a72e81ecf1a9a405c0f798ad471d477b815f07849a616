from shared.tools.thread import async
from functools import partial
	
from time import sleep
from random import random
from datetime import datetime
from time import sleep
from random import random
from datetime import datetime
from pymongo import MongoClient
from pymongo import *
from java.util import Date
from datetime import datetime
from java.text import SimpleDateFormat
import re

PAYLOAD_SEPERATOR = '|'
BARCODE_SEPERATOR = ','
ERROR = ''
LPN_PATTERN = [
        '^(M)[0-9A-Z]{11}$',
        '^(M)[0-9A-Z]{7}$',
        '^[0-9A-Z]{8}$',
        '^(I4)[0-9A-Z]{6}$',
        '^(I5)[0-9A-Z]{6}$',
        '^(R)[0-9A-Z]{11}$',
        '^(T)[0-9A-Z]{11}$',
        '^(P)[0-9A-Z]{11}$',
        '^(H0)[0-9]{6}$',
        '^(H0)[0-9]{6}     $',# 5 trailing spaces
        '^(BAL)[0-9A-Z]
	]
TOTE_PATTERN = [
        '^(TS)[0-9A-Z]{4}$',
	]
IBN_PATTERN = [
	'^[0-9A-Z]{6}$',
	]
lpnList = "(" + ")|(".join(LPN_PATTERN) + ")"
toteList = "(" + ")|(".join(TOTE_PATTERN) + ")"
ibnList =  "(" + ")|(".join(IBN_PATTERN) + ")"
#MongoDB Connection URI
uri = 'mongodb://ignitionUser:dsfasduwefnzy3848s%23@txmongowcs1.mouser.lan:27017/ignition?tls=true&tlsAllowInvalidCertificates=true&replicaSet=wcsRS1&tlsCAFile=C%3A%5CMongo%5Cmouser-lan-root-ca.crt&authMechanism=DEFAULT&authSource=ignition'

#MongoDB Database connection format
client = MongoClient(uri)
db=client.ignition

class RoutingException(Exception):
	pass
	
class NOPAYLOAD(RoutingException):pass

class NOREAD(RoutingException):pass

class NODEST(RoutingException):pass

class NORETURN(RoutingException):pass

class MULTI(RoutingException):pass


def cursorToList(cursor):
	listcursor = []
	for i in range(cursor.count()):
		listcursor.append(cursor.next())
	return listcursor

def log_data(data):
	
	
	indexID = data['IGN_IndexID_Returned']
	payload = data['IGN_Payload_Returned']
	gap = 0
	length = 0
	dest = data['IGN_Destination_Returned']
	destString = data['IGN_Dest_String_Returned']
	route = data['IGN_Route_Returned']
	Route_Reason = data['Route_Reason']
	Route_Reason_Num = data['Route_Reason_Num']
	start = data['Received_Data_Time']
	stop = system.date.now()
	stopFormat = system.date.format(stop, "yyyy-MM-dd HH:mm:ss")
	
	query = '''
	Insert into Scan16_Tracking_Table( 
	IndexID,Payload,Gap,Length,Dest_Binary_Returned,Dest_String_Returned,Route_Returned,Route_Reason,Route_Reason_Num,Divert_Path,Divert_Path_String,Divert_Reason_String,
	Divert_Reason_Num,Induct_TimeStamp,Divert_TimeStamp,Query_Time_ms,Travel_Time_ms)
	Values ( ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)'''	
	
	args = [indexID , payload , gap , length , dest , destString , route , Route_Reason , Route_Reason_Num ,0,'','',0,stopFormat,'' ,system.date.millisBetween(start, stop),0]
	
	system.db.runPrepUpdate(query, args, 'SQLServer')

			
def error_lookup(data,ERROR):
	
	query = """
	SELECT *
	FROM Scan16_Divert_Table
	Where Route_Code = ?
	"""
	results = system.db.runPrepQuery(query, [ERROR], 'SQLServer')

	# Decode the results
			
	# We get only one result if any because of the UNIQUE constraint on the table
	row = results[0]
	
	
	# Get RoutedPaylod
	
	routedString = row['Route_Code']
	# Decode the Divert columns into a bit array int
	
	# Start with no routes
	destinations = 0
	
	# Start with an Empty list for the selected Diverts
	divert_list = []
	divert_String = ''
	for selected,columnName in zip(row, results.columnNames):
		
		#Loop through and find where route is divert is selected	
		if not columnName.startswith('Divert_'): # TODO: Fix column names to match		
			continue
				
		# Get the second half on the underscore.
		# (rpartition splits on a thing, always retruning
		#  the left, split thing, and right of it)
		# And make it an int so we can shift on it
		# ... minus one because we are zero indexed, and lanes are one-indexed
		shift = int(columnName.rpartition('_')[2]) - 1 # TODO: Fix column names to match
		if row[columnName]:
			divert_list.append(columnName)
		#shift = int(columnName[-2:]) - 1
	
		# Take the result bit array so far, 
		#  and or it with the value SQL returned, 
		#  bit shifted the number of lanes 
		destinations |= selected << shift
	
	
	if destinations == 0:
		data.update({
		'Route_Reason':"Found %s Route No Lane Assigned"%(data['IGN_Route_Returned']),
		'Route_Reason_Num':5
		})	
		
	divert_String = '|'.join(divert_list)
	
			
	data.update({
		'IGN_Destination_Returned': destinations,
		'IGN_Route_Returned':routedString,
		'IGN_Dest_String_Returned': divert_String,
		'IGN_Payload_Returned':data['IGN_RawPayload']

	})
		

	return data
	
def decode_results(data):
	#Change the name of the divert table
	query = """
	SELECT *
	FROM Scan16_Divert_Table
	Where Route_Code = ?
	"""
	results = system.db.runPrepQuery(query, [data['IGN_Route_Returned']], 'SQLServer')
	
	if not results:
		raise NODEST
		
		
		
	# Decode the results
			
	# We get only one result if any because of the UNIQUE constraint on the table
	row = results[0]
	
	# Return the Routed string
	routedString = row['Route_Code']

	
	# Decode the Divert columns into a bit array int
	# Start with no routes	
	destinations = 0
	
	# Start with an Empty list for the selected Diverts
	divert_list = []
	divert_String = ''
	for selected,columnName in zip(row, results.columnNames):
		
	
		if not columnName.startswith('Divert_'): # TODO: Fix column names to match		
			continue
			
		# Get the second half on the underscore.
		# (rpartition splits on a thing, always retruning
		#  the left, split thing, and right of it)
		# And make it an int so we can shift on it
		# ... minus one because we are zero indexed, and lanes are one-indexed
		shift = int(columnName.rpartition('_')[2]) - 1 # TODO: Fix column names to match
		if row[columnName]:
			divert_list.append(columnName)
		#shift = int(columnName[-2:]) - 1
	
		# Take the result bit array so far, 
		#  and or it with the value SQL returned, 
		#  bit shifted the number of lanes 
		destinations |= selected << shift
	
	if destinations == 0:
		data.update({
		'Route_Reason':"Found %s Route No Lane Assigned"%(data['IGN_Route_Returned']),
		'Route_Reason_Num':5
		})
		
	divert_String = '|'.join(divert_list)
	
			
	data.update({
		'IGN_Destination_Returned': destinations,
		'IGN_Dest_String_Returned': divert_String
		})
		
	return data	

def IBN_lookup(data,barcodeList):
#	if not barcodeList:
#		return data,0
	
	filter={
	   "_id":{'$in':barcodeList}
	}
	project={
    	'_id': 1, 
	    'catchbox_flag': 1,
	    'consol_zone':1,
	    'va_flag':1
	}
	
	
	IBNQuery = db.outbound_scan_sort_ibn.find(
			filter=filter,
			projection=project
			)

	IBNResults = cursorToList(IBNQuery)
	IBNQuery.close()	
	IBNCount = len(IBNResults)


	if IBNCount != 0:

		zone = IBNResults[0]['consol_zone']
		vaFlag = IBNResults[0]['va_flag']
		caFlag = IBNResults[0]['catchbox_flag']
		
		if not caFlag and not vaFlag:
			dest = IBNResults[0]['consol_zone']
		else:
			dest = 'VA/CB'
		
		
		data.update({
		'IGN_Route_Returned':dest,
		'IGN_Payload_Returned':IBNResults[0]['_id']
		})

	return data,IBNCount
	
	
	
def Tote_lookup(data,barcodeList):
#	if not barcodeList:
#		return data,0	

	
	filter={
	   "_id":{'$in':barcodeList}
	}
	project={
	    '_id': 1, 
	   'destination': 1 
	}
	
	
	ToteQuery = db.qc_pack_barcode.find(
			filter=filter,
			projection=project
			)

	ToteResults = cursorToList(ToteQuery)
	ToteQuery.close()	
	Totecount = len(ToteResults)
	
	if Totecount != 0:
		data.update({
		'IGN_Route_Returned':ToteResults[0]['destination'],
		'IGN_Payload_Returned':ToteResults[0]['_id']
		})

	return data,Totecount

def LPN_lookup(data,barcodeList):
#	if not barcodeList:
#		return data,0
			
	filter={
	   "_id":{'$in':barcodeList}
	}
	project={
	    '_id': 1, 
	   'destination': 1 
	}
	
	
	LPNQuery = db.qc_pack_barcode.find(
			filter=filter,
			projection=project
			)

	LPNResults = cursorToList(LPNQuery)
	LPNQuery.close()	
	LPNCount = len(LPNResults)
	if LPNCount != 0: 
		data.update({
		'IGN_Route_Returned':LPNResults[0]['destination'],
		'IGN_Payload_Returned':LPNResults[0]['_id']
		})

	return data,LPNCount

#def lookup(data,barcodeList):
#
#	data,toteCount = Tote_lookup(data,barcodeList)
#	
#	if toteCount == 0:
#		data,ibnCount = IBN_lookup(data,barcodeList)
#		
#		if ibnCount == 0:
#			data,lpnCount = LPN_lookup(data,barcodeList)
#			
#			if lpnCount == 0:
#				raise NORETURN
#			
#	elif toteCount > 1:
#		raise MULTI
#		
#
#
#		
#	data.update(decode_results(data))
#		
#		
#	return data
	
def define_barcode(payload):
	barcode_values = payload.split(BARCODE_SEPERATOR)
	
	# Filter LPN values based on regex match
	LPN_LIST = list(dict.fromkeys([
	    barcode for barcode in barcode_values if re.match(lpnList, barcode)
	]))
	
	TOTE_LIST = list(dict.fromkeys([
	    barcode for barcode in barcode_values if re.match(toteList, barcode)
	]))
	
	IBN_LIST = list(dict.fromkeys([
	    barcode for barcode in barcode_values if re.match(ibnList, barcode)
	]))
	
	return LPN_LIST,TOTE_LIST,IBN_LIST
	
def lookup(data,LPN_List,Tote_list,IBN_list):
	
	data,lpnCount = LPN_lookup(data,LPN_List)
	
	if lpnCount == 0:
		data,toteCount = Tote_lookup(data,Tote_list)
		
		if toteCount == 0:
			data,ibnCount = IBN_lookup(data,IBN_list)
			
			if ibnCount == 0:
				raise NORETURN
			
	elif lpnCount > 1:
		raise MULTI
		


		
	data.update(decode_results(data))
		
		
	return data	
	

def lookup_and_decode(data,payload):
#	rawList = []
#	barcodeList = []
#
#	if BARCODE_SEPERATOR in payload:
#	
#		rawList = payload.split(BARCODE_SEPERATOR)
#	else:
#		rawList.append(payload)
#
#
#	for code in rawList:
#		if len(code) >= 6 and code != 'NOREAD':
#			if code not in barcodeList:
#				barcodeList.append(code)
#	
#	if len(barcodeList) == 0:
#		raise NOREAD
	LPN_List,Tote_list,IBN_list = define_barcode(payload)
	data.update(lookup(data,LPN_List,Tote_list,IBN_list))
#	data.update(lookup(data,barcodeList))		
		
	
	return data
#Change the name per use "(projectname)_gather_Data"	
@async(name = "Scan16_gather_Data_updated")	
def Scan16_gather_data(source_path):
	
	ReceiveTime = system.date.now()
	Get_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	Got_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
	Get_Counts = '/'.join(source_path.split('/')[:-2] + ['Got_Data/Counts'])
	
		
	

	rawPayload,errorCNT,multiCNT,nodestCNT,nopayloadCNT,noreadCNT,noreturnCNT,norouteCNT,successCNT,code_exc,dvt1,dvt2,dvt3,dvt4,dvt5 = [

	qv.value for qv in 
	system.tag.readBlocking([
		Get_parent_dest + '/' + 'IGN_Payload_Sent',
		Get_Counts + '/' + 'ERROR',
		Get_Counts + '/' + 'MULTI',
		Get_Counts + '/' + 'NODEST',
		Get_Counts + '/' + 'NOPAYLOAD',
		Get_Counts + '/' + 'NOREAD',
		Get_Counts + '/' + 'NORETURN',
		Get_Counts + '/' + 'NOROUTE',
		Get_Counts + '/' + 'SUCCESS',
		Get_Counts + '/' + 'CODE_EXC',
		Get_Counts + '/' + 'DVT_1',
		Get_Counts + '/' + 'DVT_2',
		Get_Counts + '/' + 'DVT_3',
		Get_Counts + '/' + 'DVT_4',
		Get_Counts + '/' + 'DVT_5'
	])]

	data = {
		'Route_Reason':"Successful Lookup",
		'Route_Reason_Num':0,
		'errorCNT':int(errorCNT),
		'multiCNT':int(multiCNT),
		'nodestCNT':int(nodestCNT),
		'nopayloadCNT':int(nopayloadCNT),
		'noreadCNT':int(noreadCNT),
		'noreturnCNT':int(noreturnCNT),
		'norouteCNT':int(norouteCNT),
		'successCNT':int(successCNT),
		'code_exc':int(code_exc),
		'dvt1':int(dvt1),
		'dvt2':int(dvt2),
		'dvt3':int(dvt3),
		'dvt4':int(dvt4),
		'dvt5':int(dvt5)
		}
	
	try:
		if PAYLOAD_SEPERATOR in rawPayload:
			indexID,payload = rawPayload.split(PAYLOAD_SEPERATOR)
			
			
			
			
			data.update({
			'IGN_IndexID_Returned':indexID,
			'IGN_RawPayload':payload
			})
		else:
			raise NOPAYLOAD
			
		
		data.update(lookup_and_decode(data,payload))
	
	except NOPAYLOAD:
		ERROR = 'NOPAYLOAD'
		data.update({
		'IGN_IndexID_Returned':99,
		'IGN_RawPayload':rawPayload})
		data.update(error_lookup(data,ERROR))
		payload = rawPayload
		
		data.update({
		'Route_Reason':"Wrong Payload Received",
		'Route_Reason_Num':2,
		'nopayloadCNT':data['nopayloadCNT']+1
		})
	except NOREAD:
		ERROR = 'NOREAD'
		data.update(error_lookup(data,ERROR))
		
		data.update({
		'Route_Reason':"Scanner Found No Barcodes",
		'Route_Reason_Num':3,
		'noreadCNT':data['noreadCNT']+1
		})
	except NORETURN:
		ERROR = 'NORETURN'
		
		data.update(error_lookup(data,ERROR))
		data.update({
		'Route_Reason':"No Results found in Production Table",
		'Route_Reason_Num':4,
		'noreturnCNT':data['noreturnCNT']+1
		})
	except NODEST:
		ERROR = 'NODEST'
		
		data.update(error_lookup(data,ERROR))
		data.update({
		'Route_Reason':"Route not in Divert Table",
		'Route_Reason_Num':6,
		'nodestCNT':data['nodestCNT']+1
		})		
	except MULTI:
		ERROR = 'MULTI'
		
		data.update(error_lookup(data,ERROR))
		data.update({
		'Route_Reason':"Multiple routes found",
		'Route_Reason_Num':6,
		'multiCNT':data['multiCNT']+1
		})	
	except:
		ERROR = 'ERROR'
		data.update(error_lookup(data,ERROR))
		
		data.update({
		'IGN_IndexID_Returned':99,
		'IGN_RawPayload':rawPayload,
		'Route_Reason':"Unexpected Error",
		'Route_Reason_Num':1,
		'errorCNT':data['errorCNT']+1
		})
	
	
	data.update({
	'Received_Data_Time':ReceiveTime,
	'Sent_Data_Time':system.date.now()
	})
	
	if data['Route_Reason_Num'] == 0:
		
		data.update({
			'successCNT':data['successCNT']+1
			})
	elif data['Route_Reason_Num'] == 5:
		
		data.update({
			'nodestCNT':data['nodestCNT']+1
			})
			
	if data['IGN_Destination_Returned']==1:
		data.update({'dvt1':data['dvt1']+1})
	elif data['IGN_Destination_Returned']==2:
		data.update({'dvt2':data['dvt2']+1})
	elif data['IGN_Destination_Returned']==4:
		data.update({'dvt3':data['dvt3']+1})
	elif data['IGN_Destination_Returned']==8:
		data.update({'dvt4':data['dvt4']+1})
	elif data['IGN_Destination_Returned']==16:
		data.update({'dvt5':data['dvt5']+1})
		
		
 	opcPaths = [
 	'ns=1;s=[L330ER_Opex_OIO]Scan16_Binary_Destination_Lookup[%s]'%(data['IGN_IndexID_Returned']),
 	'ns=1;s=[L330ER_Opex_OIO]Scan16_String_Destination_Lookup[%s]'%(data['IGN_IndexID_Returned']),
 	'ns=1;s=[L330ER_Opex_OIO]Scan16_Barcode_Lookup[%s]'%(data['IGN_IndexID_Returned'])
 	]
	
 	opcValues = [
	data['IGN_Destination_Returned'],
	data['IGN_Dest_String_Returned'],
	data['IGN_Payload_Returned'],
	]
			
 	system.opc.writeValues('Ignition OPC-UA Server', opcPaths, opcValues)	
	
	data.update({
	'code_exc':data['code_exc']+1
	})
	data['TOTAL'] = data['errorCNT']+data['multiCNT']+data['nodestCNT']+data['nopayloadCNT']+data['noreadCNT']+data['noreturnCNT']+data['norouteCNT']+data['successCNT']
	
	Got_parent_dest += '/'
	Get_Counts += '/'

			
	system.tag.writeBlocking(*zip(*[
		(Got_parent_dest + 'IGN_IndexID_Returned', data['IGN_IndexID_Returned']),	
		(Got_parent_dest + 'IGN_Route_Returned', data['IGN_Route_Returned']),			
		(Got_parent_dest + 'IGN_Payload_Returned', data['IGN_Payload_Returned']),	
		(Got_parent_dest + 'IGN_Destination_Returned', data['IGN_Destination_Returned']),	
		(Got_parent_dest + 'IGN_Dest_String_Returned', data['IGN_Dest_String_Returned']),
		(Get_Counts  + 'ERROR',data['errorCNT']),
		(Get_Counts  + 'MULTI',data['multiCNT']),
		(Get_Counts  + 'NODEST',data['nodestCNT']),
		(Get_Counts  + 'NOPAYLOAD',data['nopayloadCNT']),
		(Get_Counts  + 'NOREAD',data['noreadCNT']),
		(Get_Counts  + 'NORETURN',data['noreturnCNT']),
		(Get_Counts  + 'NOROUTE',data['norouteCNT']),
		(Get_Counts  + 'SUCCESS',data['successCNT']),
		(Get_Counts  + 'TOTAL',data['TOTAL']),
		(Get_Counts  + 'CODE_EXC',data['code_exc']),
		(Get_Counts  + 'DVT_1',data['dvt1']),
		(Get_Counts  + 'DVT_2',data['dvt2']),
		(Get_Counts  + 'DVT_3',data['dvt3']),
		(Get_Counts  + 'DVT_4',data['dvt4']),
		(Get_Counts  + 'DVT_5',data['dvt5'])
	]))
		




	log_data(data)
	
	
@async(name = "Scan16_Divert_Confirmation")	
def Scan16_Divert_Confirmation(source_path):
	DIVERTASSIGNMENT = {
	0:'Divert_05',
	1:'Divert_01',
	2:'Divert_02',
	4:'Divert_03',
	8:'Divert_04',
	16:'Divert_05'
	}
	comma = ','
	opcServer = 'Ignition OPC-UA Server'
	date_format = "yyyy-MM-dd HH:mm:ss"
	diverted_time = system.date.now()
	diverted_time_fmt = system.date.format(diverted_time, date_format) 
	
	Get_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	Got_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
	Get_Counts = '/'.join(source_path.split('/')[:-2] + ['Got_Data/Counts'])
	
	indexid,divertedpath,successCNT,fullCNT,missedCNT,code_exc = [

	qv.value for qv in 
	system.tag.readBlocking([
		Get_parent_dest + '/' + 'IGN_IndexID_Send',
		Get_parent_dest + '/' + 'Diverted_path',
		Get_Counts + '/' + 'SUCCESS',
		Get_Counts + '/' + 'FULL',
		Get_Counts + '/' + 'MISSED',
		Get_Counts + '/' + 'CODE_EXC'
	])]
	
	successCNT = int(successCNT)
	code_exc = int(code_exc)
	
	itemPaths = [
		'ns=1;s=[L330ER_Opex_OIO]Scan16_Barcode_Lookup[%s]'%(indexid)
	]
	opcData = system.opc.readValues(opcServer, itemPaths)
	
	payload = opcData[0].value

#	if comma in payload:
#		timeQuery = '''
#				SELECT TOP(100)*
#				FROM Scan16_Tracking_Table
#				WHERE IndexID = ? 
#				order by inductindx desc
#				'''
#		timeArgs = [
#		indexid
#		]
#	else:

	timeQuery = '''
		SELECT TOP(100)*
		FROM Scan16_Tracking_Table
		WHERE IndexID = ? and Payload = ?
		order by inductindx desc
		'''
		
	timeArgs = [
	indexid,
	payload
	]
	
	
	results = system.db.runPrepQuery(timeQuery, timeArgs, 'SQLServer')
	
	row = results[0]
	
	
	date_parser = SimpleDateFormat(date_format)
	inductindx = row['inductindx']
	
	
	converted_date = date_parser.parse(row['Induct_TimeStamp'])
	converted_date_2 = date_parser.parse(diverted_time_fmt)
	
	timeddiff = system.date.secondsBetween(converted_date, converted_date_2)
	
#	if comma in payload:
	query = '''
			UPDATE Scan16_Tracking_Table
			SET	Divert_Path = ?,
				Divert_Path_String = ?,
				Divert_Reason_String = ?,
				Divert_Reason_Num = ?,
				Divert_TimeStamp = ?,
				Travel_Time_ms = ?
			
			WHERE inductindx = ? 
			'''
		
	args = [
	
	divertedpath,
	DIVERTASSIGNMENT.get(divertedpath,'Unknown'),
	'Successful Divert',
	0,
	diverted_time_fmt,
	timeddiff,
	inductindx
	]	
	
	
#	else:
#		query = '''
#			UPDATE Scan16_Tracking_Table
#			SET	Divert_Path = ?,
#				Divert_Path_String = ?,
#				Divert_Reason_String = ?,
#				Divert_Reason_Num = ?,
#				Divert_TimeStamp = ?,
#				Travel_Time_ms = ?
#			
#			WHERE IndexID = ? and Payload = ?
#			'''
#			
#		args = [
#		
#		divertedpath,
#		DIVERTASSIGNMENT.get(divertedpath,'Unknown'),
#		'Successful Divert',
#		0,
#		diverted_time_fmt,
#		timeddiff,
#		indexid,
#		payload
#		]
	
	system.db.runPrepUpdate(query, args,'SQLServer')
	
	Get_Counts += '/'
	Got_parent_dest += '/'
		
	successCNT = successCNT+1
	code_exc = code_exc+1

	total = successCNT
	
	system.tag.writeBlocking(*zip(*[
		(Get_Counts  + 'MISSED',0),
		(Get_Counts  + 'FULL',0),
		(Get_Counts  + 'SUCCESS',successCNT),
		(Get_Counts  + 'TOTAL',total),
		(Get_Counts  + 'CODE_EXC',code_exc),
#		(Got_parent_dest + 'Diverted_IndexID',indexid)
#		(Got_parent_dest + 'Diverted_Payload',payload)
	]))