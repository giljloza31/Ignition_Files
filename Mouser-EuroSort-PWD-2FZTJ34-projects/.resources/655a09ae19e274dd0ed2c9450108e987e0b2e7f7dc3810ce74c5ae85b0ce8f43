from shared.tools.thread import async
from shared.tools.meta import is_redundant_active
from functools import partial
	
from time import sleep
from random import random
from datetime import datetime
from time import sleep
from random import random
from datetime import datetime

from java.util import Date
import re

from pymongo import MongoClient
from pymongo import *
	
#MongoDB Connection URI
uri = 'mongodb://ignitionUser:dsfasduwefnzy3848s%23@txmongowcs1.mouser.lan:27017/ignition?tls=true&tlsAllowInvalidCertificates=true&replicaSet=wcsRS1&tlsCAFile=C%3A%5CMongo%5Cmouser-lan-root-ca.crt&authMechanism=DEFAULT&authSource=ignition'
#uri = 'mongodb://testUser:IgnitionShip2634%23@txmongowcsdev1.mouser.lan:27017/IgnitionDB?tls=true&tlsAllowInvalidCertificates=true&authMechanism=DEFAULT&tlsCAFile=C%3A%5CUsers%5Csvc.ignition%5CDesktop%5Ckeyfile%5Cmouser-lan-root-ca+%282%29.crt'
#MongoDB Database connection format
client = MongoClient(uri,connectTimeoutMS=5000, socketTimeoutMS=5000)
db=client.ignition
#db=client.ignitionTest


CACHE_LIFESPAN = 3.0 # seconds
LABEL_PRINT_TIMEOUT = 3.0 # seconds

# https://regex101.com/r/OJMs5F/1
CODE_SEP_PATTERN = re.compile(u'[,]')
STR_SEP_PATTERN = re.compile(u'[;]')

LANE_ASSIGNMENT = {
0:'RECIRC',
1:'LANE 01',
2:'LANE 02',
4:'LANE 03',
8:'LANE 04',
16:'LANE 05',
32:'LANE 06'
}


class RoutingException(Exception):
	pass

class NOREAD(RoutingException):
	def _init_(self,data,payload,indexid):
		self.data = data
		self.payload = payload
		self.indexid = indexid

class NOROUTE(RoutingException):
	def _init_(self,data,payload,indexid):
		self.data = data
		self.payload = payload
		self.indexid = indexid
		
class NODATA(RoutingException):
	def _init_(self,data,payload,indexid):
		self.data = data
		self.payload = payload
		self.indexid = indexid

class NODEST(RoutingException):
	def _init_(self,data,payload,indexid):
		self.data = data
		self.payload = payload
		self.indexid = indexid	

class IncorrectPayload(RoutingException):
	def _init_(self,rawpayload):
		self.data = data
		self.rawpayload = rawpayload
		
	

def cursorToList(cursor):
	listcursor = []
	for i in range(cursor.count()):
		listcursor.append(cursor.next())
	return listcursor

def lookup_and_decode(data,payload):
	Barcodes = []
	comma = ','


	if payload == "NOREAD" or payload == '':
		raise NOREAD(data,payload,data['IGN_IndexID_Returned'])

	if comma in payload:
		Barcodes = payload.split(",")
	else:
		Barcodes.append(payload)
	filter={
	   "_id":{'$in':Barcodes}
	}
	project={
	    '_id': 1, 
	   'destination': 1 
	}
	
	
	BarcodeQuery = db.qc_pack_barcode.find(
			filter=filter,
			projection=project
			)

	Barcoderesults = cursorToList(BarcodeQuery)
	BarcodeQuery.close()	
	Barcodecount = len(Barcoderesults)
	
	
	
	
	if Barcodecount == 0:
		raise NODEST(data,payload,data['IGN_IndexID_Returned'])
		
	dest = Barcoderesults[0]['destination']
	
	
	
	query = """
			SELECT *
			FROM Autoship_Routing_1
			Where RouteCode = ?
			"""
	results = system.db.runPrepQuery(query, [dest], 'SQLServer')
	
	if not results:
		raise NOROUTE(data,payload,data['IGN_IndexID_Returned'])
	# Decode the results
	
	# We get only one result if any because of the UNIQUE constraint on the table
	row = results[0]
	
	#
	
	#assert all([carrier, shipvia, boxsize]), 'Some values did not return for (carrier, shipvia, boxsize): %r, %r, %r' % (carrier, shipvia, boxsize)
	
	# Decode the Lane columns into a bit array int
	# Start with no routes
	destinations = 0
	dest_list = []
	dest_string = ''
	for selected,columnName in zip(row, results.columnNames):
		
	
		if not columnName.startswith('Lane_'): # TODO: Fix column names to match		
			continue
			
		# Get the second half on the underscore.
		# (rpartition splits on a thing, always retruning
		#  the left, split thing, and right of it)
		# And make it an int so we can shift on it
		# ... minus one because we are zero indexed, and lanes are one-indexed
		shift = int(columnName.rpartition('_')[2]) - 1 # TODO: Fix column names to match
		#shift = int(columnName[-2:]) - 1
		if row[columnName]:
			dest_list.append(columnName)
		# Take the result bit array so far, 
		#  and or it with the value SQL returned, 
		#  bit shifted the number of lanes 
		destinations |= selected << shift
	
	
	

	dest_string = ",".join(dest_list)
		
	data.update({

		'IGN_Destination_Returned': destinations,
		'IGN_Payload_Returned':Barcoderesults[0]['_id'],
		'IGN_Route_Returned':Barcoderesults[0]['destination'],
		'IGN_Dest_String_Returned': dest_string

	})
	
	return data

	
def decode(data,route):
	query = """
			SELECT *
			FROM Autoship_Routing_1
			Where RouteCode = ?
			"""
	results = system.db.runPrepQuery(query, [route], 'SQLServer')
	
	if not results:
		raise NOROUTE(data,route)
	# Decode the results
	
	# We get only one result if any because of the UNIQUE constraint on the table
	row = results[0]
	
	#
	
	#assert all([carrier, shipvia, boxsize]), 'Some values did not return for (carrier, shipvia, boxsize): %r, %r, %r' % (carrier, shipvia, boxsize)
	
	# Decode the Lane columns into a bit array int
	# Start with no routes
	destinations = 0
	dest_list = []
	dest_string = ''
	for selected,columnName in zip(row, results.columnNames):
		
	
		if not columnName.startswith('Lane_'): # TODO: Fix column names to match		
			continue
			
		# Get the second half on the underscore.
		# (rpartition splits on a thing, always retruning
		#  the left, split thing, and right of it)
		# And make it an int so we can shift on it
		# ... minus one because we are zero indexed, and lanes are one-indexed
		shift = int(columnName.rpartition('_')[2]) - 1 # TODO: Fix column names to match
		#shift = int(columnName[-2:]) - 1
		if row[columnName]:
			dest_list.append(columnName)
		# Take the result bit array so far, 
		#  and or it with the value SQL returned, 
		#  bit shifted the number of lanes 
		destinations |= selected << shift
	
	
	

	dest_string = ",".join(dest_list)
	data.update({
	
			'IGN_Destination_Returned': destinations,
			'IGN_Payload_Returned':route,
			'IGN_Route_Returned':route,
			'IGN_Dest_String_Returned': dest_string
	
		})
			
	return data	
		
			
@async(name = "Autoship_Gather_Data_update")		
def Autoship_gather_data(source_path):
	data = {}
	timeStart = system.date.now()
	GET_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	GOT_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
	zeroCount = 0	
	
	
	raw_barcode, zeroCNT = [

		qv.value for qv in 
		system.tag.readBlocking([
			GET_parent_dest + '/' + 'IGN_Payload_Sent',
			GOT_parent_dest + '/' + 'Zero_Count'
		])]
		

	try:
		if not raw_barcode:
			raise NODATA
		
		if raw_barcode.count('|')==1:
			indexid,payload = raw_barcode.split('|')
		else:
			raise IncorrectPayload(data,raw_barcode)
		
		
		if len(indexid) == 0:
			
			zeroCount = int(zeroCNT)
			zeroCount += 1
			raise IncorrectPayload(data,raw_barcode)
		
		data = {
		'IGN_IndexID_Returned':indexid,
		'IGN_RawPayload':raw_barcode,
	
		}
	
		data.update(lookup_and_decode(data,payload))
	
	except NOREAD as logs:
		
		data.update(decode(data,'NOREAD'))

	
	except NOROUTE as logs:
		
		data.update(decode(data,'NOROUTE'))

		
	except NODATA as logs:
		data.update(decode(data,'NODATA'))

	except NODEST as logs:
		data.update(decode(data,'NODEST'))
	
	except IncorrectPayload as logs:
		lastIndexID = int(system.tag.readBlocking('[Mouser]Mouser/Autoship_Updated/IGN_Query/Got_Data/indexid_Returned')[0].value)

		if lastIndexID == 399:
			lastIndexID = 101
	
		else:
			lastIndexID += 1
		data.update({
			'IGN_IndexID_Returned':lastIndexID
		})
		indexid = lastIndexID

		
	except:
		data.update(decode(data,'ERROR'))

	
	tagPaths = [
		'[Mouser]Mouser/Autoship_Updated/IGN_Query/Got_Data/destination',
		'[Mouser]Mouser/Autoship_Updated/IGN_Query/Got_Data/indexid_Returned',
		'[Mouser]Mouser/Autoship_Updated/IGN_Query/Got_Data/Route_Returned',
		'[Mouser]Mouser/Autoship_Updated/IGN_Query/Got_Data/Dest_Returned',
		'[Mouser]Mouser/Autoship_Updated/IGN_Query/Got_Data/Zero_Count'
		]
		
	values = [
	
	data['IGN_Destination_Returned'],
	data['IGN_IndexID_Returned'],
	data['IGN_Route_Returned'],
	data['IGN_Dest_String_Returned'],
	zeroCount
	
	]
	
	system.tag.writeBlocking(tagPaths, values)
	
	opcPaths = [

	'ns=1;s=[L3100ERS2_Autoship_Mezz]ASM1030_Binary_Destination_Lookup[%s]'%(indexid),
	'ns=1;s=[L3100ERS2_Autoship_Mezz]ASM1030_Barcode_Lookup[%s]'%(indexid),
	'ns=1;s=[L3100ERS2_Autoship_Mezz]ASM1030_String_Destination_Lookup[%s]'%(indexid)
	]
	
	opcValues = [
		data['IGN_Destination_Returned'],
		data['IGN_Payload_Returned'],
		data['IGN_Dest_String_Returned']
		]
		
	system.opc.writeValues('Ignition OPC-UA Server', opcPaths, opcValues)
	logData(data)
	mongoupdate(data)
def logData(data):
	
	inductQuery = '''
	INSERT INTO AutoshipInduct_Table
	(timestamp,json_data)
	VALUES (?,?)
	'''
	
	
	inductData = system.util.jsonEncode(data)
	inductArgs = [system.date.now(),inductData]
	system.db.runPrepUpdate(inductQuery, inductArgs, 'SQLServer')
		
def mongoupdate(data):
		data.update({
		'timestamp':datetime.utcnow()
				})
		db.Autoship_InductDB.insert(data)	