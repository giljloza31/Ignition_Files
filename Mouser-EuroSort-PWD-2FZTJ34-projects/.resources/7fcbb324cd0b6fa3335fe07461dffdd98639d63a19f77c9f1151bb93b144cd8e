from shared.tools.thread import async
from shared.tools.meta import is_redundant_active
from functools import partial
	
from time import sleep
from random import random
from datetime import datetime
from time import sleep
from random import random
from datetime import datetime

from java.util import Date
import re

from pymongo import MongoClient
from pymongo import *
	
#MongoDB Connection URI
uri = 'mongodb://ignitionUser:dsfasduwefnzy3848s%23@txmongowcs1.mouser.lan:27017/ignition?tls=true&tlsAllowInvalidCertificates=true&replicaSet=wcsRS1&tlsCAFile=C%3A%5CMongo%5Cmouser-lan-root-ca.crt&authMechanism=DEFAULT&authSource=ignition'
#uri = 'mongodb://testUser:IgnitionShip2634%23@txmongowcsdev1.mouser.lan:27017/IgnitionDB?tls=true&tlsAllowInvalidCertificates=true&authMechanism=DEFAULT&tlsCAFile=C%3A%5CUsers%5Csvc.ignition%5CDesktop%5Ckeyfile%5Cmouser-lan-root-ca+%282%29.crt'
#MongoDB Database connection format
client = MongoClient(uri,connectTimeoutMS=5000, socketTimeoutMS=5000)
db=client.ignition
#db=client.ignitionTest


CACHE_LIFESPAN = 3.0 # seconds
LABEL_PRINT_TIMEOUT = 3.0 # seconds

# https://regex101.com/r/OJMs5F/1
CODE_SEP_PATTERN = re.compile(u'[,]')
STR_SEP_PATTERN = re.compile(u'[;]')

LANE_ASSIGNMENT = {
0:'RECIRC',
1:'LANE 01',
2:'LANE 02',
4:'LANE 03',
8:'LANE 04',
16:'LANE 05',
32:'LANE 06'
}


class RoutingException(Exception):
	pass

class NOREAD(RoutingException):
	def _init_(self,data,payload,indexid):
		self.data = data
		self.payload = payload
		self.indexid = indexid

class NOROUTE(RoutingException):
	def _init_(self,data,payload,indexid):
		self.data = data
		self.payload = payload
		self.indexid = indexid

class MULTIPLE(RoutingException):
	def _init_(self,data,payload,indexid):
		self.data = data
		self.payload = payload
		self.indexid = indexid

class NODEST(RoutingException):
	def _init_(self,data,payload,indexid):
		self.data = data
		self.payload = payload
		self.indexid = indexid		

def cursorToList(cursor):
	listcursor = []
	for i in range(cursor.count()):
		listcursor.append(cursor.next())
	return listcursor

def lookup_and_decode(data,payload):
	Barcodes = []
	comma = ','


	if payload == "NOREAD" or payload == '':
		raise NOREAD(data,payload,data['IGN_IndexID_Returned'])
	
	elif payload == "MULTIPLE":
		raise MUTIPLE(data,payload,data['IGN_IndexID_Returned'])
	
	if comma in payload:
	
		Barcodes = payload.split(",")	
	else:
		Barcodes.append(payload)
		
	filter={
	   "_id":{'$in':Barcodes}
	}
	project={
	    '_id': 1, 
	   'destination': 1 
	}
	
	
	BarcodeQuery = db.qc_pack_barcode.find(
			filter=filter,
			projection=project
			)

	Barcoderesults = cursorToList(BarcodeQuery)
	BarcodeQuery.close()	
	Barcodecount = len(Barcoderesults)
	
	
	
	
	if Barcodecount == 0:
		raise NODEST(data,payload,data['IGN_IndexID_Returned'])
		
	dest = Barcoderesults[0]['destination']
	
	
	
	query = """
			SELECT *
			FROM QP_Routing
			Where RouteCode = ?
			"""
	results = system.db.runPrepQuery(query, [dest], 'SQLServer')
	
	if not results:
		raise NOROUTE(data,payload)
	# Decode the results
	
	# We get only one result if any because of the UNIQUE constraint on the table
	row = results[0]
	
	#
	
	#assert all([carrier, shipvia, boxsize]), 'Some values did not return for (carrier, shipvia, boxsize): %r, %r, %r' % (carrier, shipvia, boxsize)
	
	# Decode the Lane columns into a bit array int
	# Start with no routes
	destinations = 0
	dest_list = []
	dest_String = ''
	for selected,columnName in zip(row, results.columnNames):
		
	
		if not columnName.startswith('Lane_'): # TODO: Fix column names to match		
			continue
			
		# Get the second half on the underscore.
		# (rpartition splits on a thing, always retruning
		#  the left, split thing, and right of it)
		# And make it an int so we can shift on it
		# ... minus one because we are zero indexed, and lanes are one-indexed
		shift = int(columnName.rpartition('_')[2]) - 1 # TODO: Fix column names to match
		if row[columnName]:
			dest_list.append(columnName)
		#shift = int(columnName[-2:]) - 1
	
		# Take the result bit array so far, 
		#  and or it with the value SQL returned, 
		#  bit shifted the number of lanes 
		destinations |= selected << shift
	
	
	dest_String = '|'.join(dest_list)

		
	data.update({
		'IGN_Destination_Returned': destinations,
		'IGN_Payload_Returned':Barcoderesults[0]['_id'],
		'IGN_Route_Returned':Barcoderesults[0]['destination'],
		'IGN_Dest_String_Returned': dest_String

	})
	
	return data
	
			
@async(name = "QP_Gather_Data_updated")		
def QP_gather_data(source_path):
	timeStart = system.date.now()
	GET_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	GOT_parent_dest = '/'.join(source_path.split('/')[:-2] + ['Got_Data'])
	Get_Counts = '[Mouser]Mouser/QP_Sorter_Updated/IGN_Query/Got_Data/Counts' 	
	raw_barcode,dvt1,dvt2,dvt3,dvt4= [

		qv.value for qv in 
		system.tag.readBlocking([
			GET_parent_dest + '/' + 'IGN_Payload_Sent',
			Get_Counts + '/' + 'DVT_1',
			Get_Counts + '/' + 'DVT_2',
			Get_Counts + '/' + 'DVT_3',
			Get_Counts + '/' + 'DVT_4',
		])]
		
	
	indexid,payload = raw_barcode.split('|')
	
	data = {
	'IGN_IndexID_Returned':indexid,
	'IGN_RawPayload':raw_barcode,
	}
	
	try:
				

		
		data.update(lookup_and_decode(data,payload))
	
	except NOREAD as logs:
		
		
		data.update({
			'IGN_Destination_Returned': (1<<(3-1)),
			'IGN_Payload_Returned':raw_barcode,
			'IGN_Route_Returned':"NOREAD",
			'IGN_Dest_String_Returned': LANE_ASSIGNMENT.get((1<<(3-1)),'UNKNOWN')

		
		})
	
	except NOROUTE as logs:
		data.update({
			'IGN_Destination_Returned': (1<<(3-1)),
			'IGN_Payload_Returned':raw_barcode,
			'IGN_Route_Returned':"NOROUTE",
			'IGN_Dest_String_Returned': LANE_ASSIGNMENT.get((1<<(3-1)),'UNKNOWN')
		
		
		})
	
	except MULTIPLE as logs:
		data.update({
			'IGN_Destination_Returned': (1<<(3-1)),
			'IGN_Payload_Returned':raw_barcode,
			'IGN_Route_Returned':"MUPLTIPLE",
			'IGN_Dest_String_Returned': LANE_ASSIGNMENT.get((1<<(3-1)),'UNKNOWN')
		
		
		})
	
	except NODEST as logs:
		data.update({

			'IGN_Destination_Returned': (1<<(3-1)),
			'IGN_Payload_Returned':raw_barcode,
			'IGN_Route_Returned':"NODEST",
			'IGN_Dest_String_Returned': LANE_ASSIGNMENT.get((1<<(3-1)),'UNKNOWN')
		
		
		})
		
	except:
		data.update({
			'IGN_Destination_Returned': (1<<(3-1)),
			'IGN_Payload_Returned':raw_barcode,
			'IGN_Route_Returned':"ERROR",
			'IGN_Dest_String_Returned': LANE_ASSIGNMENT.get((1<<(3-1)),'UNKNOWN')
		
		
		})
	
	
	if data['IGN_Destination_Returned']==1:
		dvt1 = int(dvt1)+1
	elif data['IGN_Destination_Returned']==2:
		dvt2 = int(dvt2)+1
	elif data['IGN_Destination_Returned']==4:
		dvt3 = int(dvt3)+1
	elif data['IGN_Destination_Returned']==8:
		dvt4 = int(dvt4)+1
	tagPaths = [
		'[Mouser]Mouser/QP_Sorter_Updated/IGN_Query/Got_Data/destination',
		'[Mouser]Mouser/QP_Sorter_Updated/IGN_Query/Got_Data/indexid_Returned',
		'[Mouser]Mouser/QP_Sorter_Updated/IGN_Query/Got_Data/Route_Returned',
		'[Mouser]Mouser/QP_Sorter_Updated/IGN_Query/Got_Data/Dest_String',
		'[Mouser]Mouser/QP_Sorter_Updated/IGN_Query/Got_Data/Counts/DVT_1',
		'[Mouser]Mouser/QP_Sorter_Updated/IGN_Query/Got_Data/Counts/DVT_2',
		'[Mouser]Mouser/QP_Sorter_Updated/IGN_Query/Got_Data/Counts/DVT_3',
		'[Mouser]Mouser/QP_Sorter_Updated/IGN_Query/Got_Data/Counts/DVT_4'
		]
		
	values = [
	
	data['IGN_Destination_Returned'],
	data['IGN_IndexID_Returned'],
	data['IGN_Route_Returned'],
	data['IGN_Dest_String_Returned'],
	dvt1,
	dvt2,
	dvt3,
	dvt4
	]
	
	system.tag.writeBlocking(tagPaths, values)
	
	opcPaths = [
	'ns=1;s=[L3100ERS2_Autoship_Mezz]ASM3000_Binary_Destination_Lookup[%s]'%(indexid),
	'ns=1;s=[L3100ERS2_Autoship_Mezz]ASM3000_String_Destination_Lookup[%s]'%(indexid),
	'ns=1;s=[L3100ERS2_Autoship_Mezz]ASM3000_String_Destination_Lookup[%s]'%(indexid)
	]
	
	opcValues = [
		data['IGN_Destination_Returned'],
		data['IGN_Payload_Returned'],
		data['IGN_Dest_String_Returned']
		]
		
	system.opc.writeValues('Ignition OPC-UA Server', opcPaths, opcValues)
	QPQuery = '''
    	INSERT INTO QP_TrackingTable
    	(timestamp,json_data)
    	VALUES (?,?)
    	'''
#    	
	QPData = system.util.jsonEncode(data)
	QPArgs = [system.date.now(),QPData]
	system.db.runPrepUpdate(QPQuery, QPArgs, 'SQLServer')
	
	mongoupdate(data)
	
def mongoupdate(data):
		data.update({
		'timestamp':datetime.utcnow()
				})
		db.QP_InductDB.insert(data)	