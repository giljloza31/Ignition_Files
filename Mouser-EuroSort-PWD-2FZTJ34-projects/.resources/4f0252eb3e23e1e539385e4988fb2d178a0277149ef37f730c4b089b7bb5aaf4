from shared.tools.global import ExtraGlobal
from shared.tools.thread import async
from shared.tools.meta import is_redundant_active
from functools import partial

from time import sleep
from random import random
from datetime import datetime
import re


from shared.pwd.handshake import push_sequence


class RoutingException(Exception):
	pass

# Errors in rule handling
class NoMatchingRoute(RoutingException): pass

class NoMatchingRule(RoutingException): pass

class ToteRouting(RoutingException): pass

class MultipleMatchingRules(RoutingException): pass

class AmbiguousRoute(RoutingException): pass

class NoReadBypass(ToteRouting): pass

# https://regex101.com/r/OJMs5F/1
SEPATATOR_PATTERN = re.compile(u'[,\x1d]', re.UNICODE)


def match_rules(raw_barcode):
	# Check special cases on shipping rules to convert the raw barcode to the routing token:
	
	routing_barcodes = []
	
	# check null case
	if not raw_barcode: 
		# i.e. '' (case 7: null/blank)
		routing_barcodes.append('NO DATA')
		raise NotImplementedError("Set %r to recirculate!" % raw_barcode)
	
	# if delimited, check that at least one token matches a rule
	elif SEPATATOR_PATTERN.findall(raw_barcode):
		# i.e. 4213922300051,1ZY172210403414629		
		for token in SEPATATOR_PATTERN.split(raw_barcode): #raw_barcode.split(','):
			try:
				matched = match_rules(token)
				
				if matched:
					routing_barcodes.extend(matched)
					
			except NoMatchingRule:
				pass
				
		if routing_barcodes:
			return routing_barcodes
	
	# check rules	
	if re.match('(8)[0-9A-Z]{5}',raw_barcode):
		routing_barcodes.append(raw_barcode)
		#routing_barcode = raw_barcode
	elif re.match('(R)[0-9A-Z]{5}',raw_barcode):
		routing_barcodes.append(raw_barcode)
		#routing_barcode = raw_barcode
		
	elif raw_barcode.startwith('RVT'):
		raise ToteRouting(raw_barcode)
		
	elif raw_barcode == ('NOREAD'):
		raise NoReadBypass(raw_barcode)
		
	else:
		if raw_barcode.startswith('TEST-'):
			routing_barcodes.append(raw_barcode[5:])
		else:
			raise NoMatchingRule("Unexpected barcode value: %r" % raw_barcode)
	
	if not routing_barcodes:
		raise NoMatchingRule("Unexpected barcode value: %r" % raw_barcode)

	return routing_barcodes




def lookup_and_decode_barcode(raw_barcode):
	

	routing_barcodes = match_rules(raw_barcode)
	payload = {}
    												
        
	if not routing_barcodes:
   		raise NoMatchingRule("No barcodes match rules: %r" % raw_barcode)

       	

	query = """
		select r.*
		from InboundReceiptInfo as p
		inner join RedReceiving_RouteTable as r
		on (p.zone = r.Route_Code and p.zone <> '')
		or (r.Route_Code = 'NODESTINATION' and p.zone = '')
		where p.ibn in (%s)
		""" % (','.join('?' for x in routing_barcodes),)
	
	results = system.db.runPrepQuery(query, routing_barcodes, 'SQLServer')
	
	if not results:
		raise NoMatchingRoute('No matching routing found for %r (from %r)' % (routing_barcodes, raw_barcode))
	if len(results) > 1:
		raise AmbiguousRoute( 'Ambiguous routing for %r (from %r)' % (routing_barcodes, raw_barcode))
	
	# Decode the results
	
	# We get only one result if any because of the UNIQUE constraint on the table
	row = results[0]
	
	# Init
	routed_barcode = row['Route_Code']
	
	runRev = row['RunRev']

	
	
	
	# Decode the Lane columns into a bit array int
	# Start with no routes
	destinations = 0
	
	for selected,columnName in zip(row, results.columnNames):
		
		if not columnName.startswith('Lane_'): # TODO: Fix column names to match		
			continue
			
		# Get the second half on the underscore.
		# (rpartition splits on a thing, always retruning
		#  the left, split thing, and right of it)
		# And make it an int so we can shift on it
		# ... minus one because we are zero indexed, and lanes are one-indexed
		shift = int(columnName.rpartition('_')[2]) - 1 # TODO: Fix column names to match
		#shift = int(columnName[-2:]) - 1
	
		# Take the result bit array so far, 
		#  and or it with the value SQL returned, 
		#  bit shifted the number of lanes 
		destinations |= selected << shift
	
	payload.update({
		'IGN_Destination_Returned': destinations,
		'IGN_Barcode_Returned': raw_barcode,
		'IGN_RouteCode_Returned': routed_barcode,
		'IGN_RunRev_Returned': runRev,
	})
	
	return payload


@async(name="Red_Receiving-Route-GatherData")
def gather_red_data(source_path):

	timestart = datetime.now().isoformat()
	parent_dest = '/'.join(source_path.split('/')[:-2] + ['Get_Data'])
	
	sequence_id, raw_barcode, ack_opc_path = [
		qv.value for qv in 
		system.tag.readBlocking([
			parent_dest + '/' + 'IGN_IndexID_Sent',
			parent_dest + '/' + 'IGN_Barcode_Sent',
			parent_dest + '/' + 'IGN_GetData_ACK.OPCItemPath'
			])]
	
	# ACK immediately now that the data's in memory
	system.tag.writeBlocking([
		parent_dest + '/' + 'IGN_GetData_ACK',
		], [True])			
			
	# decode and lookup what the route for a barcode is
	# handle exceptional/failed lookups
	data = {
		'IGN_IndexID_Returned': sequence_id,
		'Get_Time': timestart,
		
		'mode': 50, # shipping get/got (arb. choice)
	}
	try:
		try:
			data.update(lookup_and_decode_barcode(raw_barcode))
		except Exception, error:
			system.util.getLogger('Shipping Sorter Exception').trace(repr(error))
			raise error

	except ToteRouting:
		data.update({
			'IGN_Destination_Returned': (1<<(5-1)), # 0x1000 <-- Lane 4
			'IGN_Barcode_Returned': raw_barcode,
			'IGN_RouteCode_Returned': 'RVT'.join(('','','')), # literally '--'
			'IGN_RunRev_Returned': 1,
			'IGN_IndexID_Returned': sequence_id,
			
		})

	except NoReadBypass:
		data.update({
			'IGN_Destination_Returned': (1<<(5-1)), # 0x1000 <-- Lane 4
			'IGN_Barcode_Returned': raw_barcode,
			'IGN_RouteCode_Returned': '-'.join(('','','')), # literally '--'
			'IGN_IndexID_Returned': sequence_id,
			'IGN_RunRev_Returned': 1,
		})
		
	except (NoMatchingRoute, NoMatchingRule, MultipleMatchingRules, AmbiguousRoute):
		data.update({
			'IGN_Destination_Returned': (1<<(5-1)), # recirc
			'IGN_Barcode_Returned': raw_barcode,
			'IGN_RouteCode_Returned': '-'.join(('','','')), # literally '--'
			'IGN_IndexID_Returned': sequence_id,
			'IGN_RunRev_Returned': 1,
		})
				
	# handle the unexpected...
	except:
		data = {
			'IGN_Destination_Returned': (1<<(5-1)),
			'IGN_Barcode_Returned': raw_barcode,
			'IGN_RouteCode_Returned': '-'.join(('','','')), # literally '--'
			'IGN_IndexID_Returned': sequence_id,
			'IGN_RunRev_Returned': 1,
		}
		
	data['IGN_GotData_Returned'] = True		
	data['Sql_Time'] = datetime.now().isoformat()
	
	push_sequence(source_path, sequence_id, data)

	#log_induct(data)
	
def log_induct(payload):
	query = """	
		insert into [RecReceiving_Induct] (
			Destination
		,	DestinationString
		,	InductID
		,	RouteCode
		,	IBN
		,	TimeStamp
		)
		select	dd.destination
			,	dd.DestinationString
			,	? -- InductID
			,	? -- RouteCode
			,	? -- IBN
			,	getdate()
		from DestinationDecode_ as dd
		where dd.mode = 50
			and dd.destination = ?
	"""
	
	system.db.runPrepUpdate(query, [
			payload['IGN_IndexID_Returned'],
			payload['IGN_RouteCode_Returned'],
			payload['IGN_Barcode_Returned'],
			payload['IGN_Destination_Returned'],	
		], 'SQLServer')
	
