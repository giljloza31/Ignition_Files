
"""
es_platform.domain.state_store

StateStore (Mongo-backed) for ES_Platform.

Design goals:
	- Persist carriers + chutes in ONE collection: es_platform_state
	- Fast in-memory cache (optional) + Mongo as persistence layer
	- Hydrate on startup (load all docs for systemCode)
	- Safe per-entity updates via updateOne/upsert
	- Deterministic timestamps via shared.foundation.time.clock
	- Works from Gateway + Script Console (MongoProxy handles scope)

Document contract (per entity):
	{
		"systemCode": "MOUSER-ES-A19",
		"entityType": "CARRIER" | "CHUTE",
		"entityId": "<carrierId or DST-...>",
		"version": <int>,
		"updatedAtUtc": "<iso utc>",
		"updatedAtLocal": "<yyyyMMdd HH:mm:ss.SSS>",
		"updatedAtEpoch": <int ms>,
		"tzId": "<site tz id>",
		...entity fields...
	}

Important conventions:
	- Filter keys are immutable: systemCode + entityType + entityId
	- Update uses $set for fields + $inc version
	- StateStore does not own routing logic; it just stores state
"""

from shared.foundation.time import clock


COLLECTION_STATE = "es_platform_state"

ENTITY_CARRIER = "CARRIER"
ENTITY_CHUTE = "CHUTE"


class StateStore(object):
	def __init__(self, systemCode, mongo, site_tz_id="UTC", enable_cache=True):
		"""
		systemCode: e.g. "MOUSER-ES-A19"
		mongo: instance of shared.foundation.mongo.proxy.MongoProxy
		site_tz_id: e.g. "America/Chicago" (per system/site)
		enable_cache: if True, keeps in-memory dicts of carriers/chutes
		"""
		self.systemCode = systemCode
		self.mongo = mongo
		self.site_tz_id = site_tz_id
		self.enable_cache = bool(enable_cache)

		self._carriers = {}  # carrierId -> doc
		self._chutes = {}    # dst -> doc

		self._hydrated = False
		self._last_hydrate = None  # packed timestamps dict

	# ----------------------------
	# Internal helpers
	# ----------------------------

	def _key(self, entityType, entityId):
		return {
			"systemCode": self.systemCode,
			"entityType": entityType,
			"entityId": entityId
		}

	def _pack_update_meta(self):
		ts = clock.pack_timestamps(tz_id=self.site_tz_id)
		return {
			"updatedAtUtc": ts["tsUtc"],
			"updatedAtLocal": ts["tsLocal"],
			"updatedAtEpoch": ts["tsEpoch"],
			"tzId": ts["tzId"],
		}, ts

	def _cache_put(self, doc):
		if not self.enable_cache or not doc:
			return

		etype = doc.get("entityType")
		eid = doc.get("entityId")

		if etype == ENTITY_CARRIER and eid is not None:
			self._carriers[eid] = doc
		elif etype == ENTITY_CHUTE and eid is not None:
			self._chutes[eid] = doc

	def _cache_get(self, entityType, entityId):
		if not self.enable_cache:
			return None

		if entityType == ENTITY_CARRIER:
			return self._carriers.get(entityId)
		if entityType == ENTITY_CHUTE:
			return self._chutes.get(entityId)
		return None

	def _cache_del(self, entityType, entityId):
		if not self.enable_cache:
			return

		if entityType == ENTITY_CARRIER:
			if entityId in self._carriers:
				del self._carriers[entityId]
		elif entityType == ENTITY_CHUTE:
			if entityId in self._chutes:
				del self._chutes[entityId]

	# ----------------------------
	# Hydration
	# ----------------------------

	def hydrate(self, force=False):
		"""
		Load all state docs for this systemCode into cache (if enabled).
		Safe to call repeatedly.
		"""
		if self._hydrated and not force:
			return {
				"ok": True,
				"hydrated": True,
				"forced": False,
				"counts": self.counts(),
				"lastHydrate": self._last_hydrate
			}

		docs = self.mongo.find(COLLECTION_STATE, {"systemCode": self.systemCode}) or []

		# Reset cache
		if self.enable_cache:
			self._carriers = {}
			self._chutes = {}

		for d in docs:
			self._cache_put(d)

		self._hydrated = True
		self._last_hydrate = clock.pack_timestamps(tz_id=self.site_tz_id)

		return {
			"ok": True,
			"hydrated": True,
			"forced": bool(force),
			"counts": self.counts(),
			"lastHydrate": self._last_hydrate
		}

	def is_hydrated(self):
		return bool(self._hydrated)

	def last_hydrate(self):
		return self._last_hydrate

	def counts(self):
		return {
			"carriers": len(self._carriers) if self.enable_cache else None,
			"chutes": len(self._chutes) if self.enable_cache else None
		}

	# ----------------------------
	# Generic state access
	# ----------------------------

	def get(self, entityType, entityId, prefer_cache=True):
		"""
		Get one entity doc by type+id.
		"""
		if prefer_cache and self.enable_cache:
			c = self._cache_get(entityType, entityId)
			if c is not None:
				return c

		doc = self.mongo.find_one(COLLECTION_STATE, self._key(entityType, entityId))
		if doc:
			self._cache_put(doc)
		return doc

	def upsert(self, entityType, entityId, set_fields=None, inc_fields=None, set_on_insert=None):
		"""
		Upsert entity doc with:
			$set set_fields + updatedAt*
			$inc inc_fields + version
			$setOnInsert set_on_insert + identity fields
		"""
		set_fields = dict(set_fields or {})
		inc_fields = dict(inc_fields or {})
		set_on_insert = dict(set_on_insert or {})

		# Add timestamps into $set
		meta, ts = self._pack_update_meta()
		for k, v in meta.items():
			set_fields[k] = v

		# Always bump version
		inc_fields["version"] = int(inc_fields.get("version", 0)) + 1

		# Ensure identity fields exist on insert
		key = self._key(entityType, entityId)
		set_on_insert.setdefault("systemCode", self.systemCode)
		set_on_insert.setdefault("entityType", entityType)
		set_on_insert.setdefault("entityId", entityId)
		set_on_insert.setdefault("version", 0)

		update_doc = {
			"$set": set_fields,
			"$inc": inc_fields,
			"$setOnInsert": set_on_insert
		}

		self.mongo.update_one(COLLECTION_STATE, key, update_doc, upsert=True)

		# Pull fresh (or reconstruct cache) for consistency
		doc = self.mongo.find_one(COLLECTION_STATE, key)
		if doc:
			self._cache_put(doc)

		return {
			"ok": True,
			"entityType": entityType,
			"entityId": entityId,
			"updated": True,
			"ts": ts,
			"doc": doc
		}

	def delete(self, entityType, entityId):
		"""
		Delete an entity doc.
		"""
		key = self._key(entityType, entityId)
		res = self.mongo.delete_one(COLLECTION_STATE, key)
		self._cache_del(entityType, entityId)
		return {"ok": True, "deleted": True, "result": res}

	# ----------------------------
	# Carrier API
	# ----------------------------

	def get_carrier(self, carrierId, prefer_cache=True):
		return self.get(ENTITY_CARRIER, carrierId, prefer_cache=prefer_cache)

	def upsert_carrier(self, carrierId, fields=None, inc=None, on_insert=None):
		return self.upsert(ENTITY_CARRIER, carrierId, set_fields=fields, inc_fields=inc, set_on_insert=on_insert)

	def list_carriers(self, filt=None, prefer_cache=True):
		"""
		List carriers by filter. If cache enabled and prefer_cache=True, filter in memory.
		filt: dict of field->value exact matches (simple)
		"""
		filt = filt or {}
		if prefer_cache and self.enable_cache and self._hydrated:
			out = []
			for d in self._carriers.values():
				if _match_simple(d, filt):
					out.append(d)
			return out

		f = {"systemCode": self.systemCode, "entityType": ENTITY_CARRIER}
		for k, v in filt.items():
			f[k] = v
		return self.mongo.find(COLLECTION_STATE, f) or []

	# ----------------------------
	# Chute API
	# ----------------------------

	def get_chute(self, dst, prefer_cache=True):
		return self.get(ENTITY_CHUTE, dst, prefer_cache=prefer_cache)

	def upsert_chute(self, dst, fields=None, inc=None, on_insert=None):
		return self.upsert(ENTITY_CHUTE, dst, set_fields=fields, inc_fields=inc, set_on_insert=on_insert)

	def list_chutes(self, filt=None, prefer_cache=True):
		filt = filt or {}
		if prefer_cache and self.enable_cache and self._hydrated:
			out = []
			for d in self._chutes.values():
				if _match_simple(d, filt):
					out.append(d)
			return out

		f = {"systemCode": self.systemCode, "entityType": ENTITY_CHUTE}
		for k, v in filt.items():
			f[k] = v
		return self.mongo.find(COLLECTION_STATE, f) or []


# ----------------------------
# Small helpers (keep boring)
# ----------------------------

def _match_simple(doc, filt):
	"""
	Simple exact-match filter (no operators). Returns True if doc matches all keys.
	"""
	for k, v in filt.items():
		if doc.get(k) != v:
			return False
	return True


# ----------------------------
# Script Console quick test
# ----------------------------
#
# from shared.foundation.mongo.proxy import MongoProxy
# from shared.es_platform.domain.state_store import StateStore
#
# mongo = MongoProxy(connector="MongoWCS", gateway_project="ES_Platform", handler_name="MongoProxy")
# store = StateStore("MOUSER-ES-A19", mongo, site_tz_id="America/Chicago", enable_cache=True)
#
# print(store.hydrate(force=True))
# print(store.upsert_carrier("019", fields={"currentPhase":"EMPTY"}))
# print(store.upsert_chute("DST-0001-1-1-A", fields={"status":"READY","enabled":True,"faulted":False}))
# print(store.get_carrier("019"))
# print(store.get_chute("DST-0001-1-1-A"))