from shared.tools.thread import async
from shared.tools.global import ExtraGlobal
from datetime import datetime
from system.net import httpClient
from Database import db_access

import re

# Production
client = httpClient()
db_name = 'MongoWCS'

plcname = 'Mouser_HSL'
cached_scope = 'PrintData'
lifespan_time = 60*60*24 # one day of lifespan

GS = '$1D'
pattern_9digit = '^[0-9]{9}$'
BARCODE_SEPARATOR = ','  # Modify based on actual us
errorResults_dict = {
	'NOREAD':5,
	'NoLOT':8,
	'UnexpectedLOT':9,
	'OpenBox':10,
	'NoLabelExp':11,
	'NoPrintResult':16,
	'NoPrintRequestSent':13,
	'PrintInductLPNNoRead':12,
	'ShortBox':14,
	'LongBox':15,
	}
#logger for verify
logger = system.util.getLogger('Verify')

postship_tracking_numbers = ['^1Z0{13}00$','^1Z0{14}01$', '^1Z0{13}03$', '^1Z0{14}04$', '^1Z0{14}05$']
error_tracking_numbers = ['^1Z0{14}02$']
error_messages_list = [
	'^NOREAD$',
	'^NoLOT$',
	'^UnexpectedLOT$',
	'^OpenBox$',
	'^NoLabelExp$',
	'^NoPrintResult$',
	'^ShortBox$',
	'^LongBox$',
	'^NoPrintRequestSent$',
	'^PrintInductLPNNoRead$',
	]
postship_error = "(" + ")|(".join(postship_tracking_numbers) + ")"
error_labels = "(" + ")|(".join(error_tracking_numbers) + ")"
error_messages = "(" + ")|(".join(error_messages_list) + ")"

VER_PAYLOAD_PATTERN = re.compile(r"""
	^
	(?P<indexid>\d{3})						# indexID 101-399
	\|										# pipe seperator
	(?P<lpn>.*)								# LPN
	\|										# pipe seperator
	(?P<tracking>.*)						# Tracking
	$
	""", re.VERBOSE)

# Verify Errors
VER_ERROR_LIST = {
	1: 'Success',
	2: 'LPN Mismatch',
	3: 'Tracking/OrderNum Mismatched',
	4: 'NoRead Tracking',
	5: 'NoRead LPN',
	6: 'NoRecord in DB/Cache',
	7: 'API Error',
	8: 'No Label on Tamp',
	9: 'Unexpected Label on Tamp',
	10: 'Open Box',
	11: 'No Label expected',
	12: 'NoRead',
	13: 'No Print Request Sent',
	14: 'Short box',
	15: 'Long Box',
	16: 'No Print Result',
	17: 'PostShip',
	19: 'Multi LPN',
	20: 'Unexplained',
	21: 'OnHold',
	22: 'failed'
	}


class VerifyProcess:
	
	def check_payload(self,payload,data,counts):
	
		# check if payload is correct
		payload_data_match = VER_PAYLOAD_PATTERN.match(payload)
		
		# If not match return error
		if not payload_data_match:
			
			data.update({
				
				'LPN': 'NoLPN',
				'tracking':'No Tracking',
				'reason_num':2,
				'reason':VER_ERROR_LIST.get(2),
				})
				
			counts.update({
				'Improper_Payload_cnt': counts.get('Improper_Payload_cnt', 0) + 1
			})
			return data,counts
		
		# Group by key identifiers
		payload_data = payload_data_match.groupdict()
		
		data.update({
			'indexId': payload_data['indexid'],
			'LPN': payload_data['lpn'],
			'tracking':payload_data['tracking'],
			'reason_num':1,
			'reason':VER_ERROR_LIST.get(1),
			})
		counts.update({
			'Proper_Payload_cnt': counts.get('Proper_Payload_cnt', 0) + 1
			})
				

		
		return data,counts
		
		
	def identify_tracking_number(self,trackingList):
		
		for trackingNum in trackingList:
			gs_index = trackingNum.find(GS)
			if gs_index != -1:
				trackingNum = trackingNum[gs_index +len(GS):]
			
			if re.findall('<GS>',trackingNum):
				trackingNum = re.sub('<GS>','',trackingNum)
				trackingNum = trackingNum[8:]
								
				
			
			if len(trackingNum) == 34:
				return [trackingNum[-12:]]
			elif len(trackingNum) == 9:
				return [trackingNum]
			elif trackingNum.startswith('9') and len(trackingNum) in {22, 26}:
				return [trackingNum]
			elif trackingNum.startswith('1Z') and len(trackingNum) == 18:
				return [trackingNum]
			elif len(trackingNum) == 10 or trackingNum.startswith('EP') and len(trackingNum) == 13:
				return [trackingNum]
			
		return []	


			
	def identify_and_extract(self,tracking_list,data,counts):
		translate = {
		'NoLOT':'nolot_cnt',
		'UnexpectedLOT':'unexpectedlot_cnt',
		'OpenBox':'openbox_cnt',
		'NoLabelExp':'nolabelexp_cnt',
		'NoPrintResult':'noprintresult_cnt',
		'NoPrintRequestSent':'noprnrqstsent_cnt',
		'PrintInductLPNNoRead':'PrintInductLPNNoRead_cnt',
		'ShortBox':'shortbox_cnt',
		'LongBox':'longbox_cnt'
		}
		

		error_results = ''
		tr_results = []
		invoice_results = []
		
		for barcode in tracking_list:
			
			#----1Z---02------1Z0000000000000002
			if re.match(error_labels,barcode):
				tracking = barcode 
				reason_num = 21
				count = 'PostShip_OnHold_cnt'
			
			#----1Z-----03--04---05----00---1Z0000000000000005
			elif re.match(postship_error, barcode):
				tracking = barcode 
				reason_num  =  17
				count = 'PostShip'
				
				
			elif re.match(pattern_9digit,barcode):
				invoice_results.append(barcode)
			
			#-----PLC Identified Errors---- OPENBOX ETC....NOPRINTREQUEST----
			elif re.match(error_messages,barcode):
				tracking = barcode
				reason_num = errorResults_dict.get(error_results,20)
				count = translate.get(tr_results)
			else:
				tr_results.append(barcode)
		
	
		 
		data.update({
			'tracking_list':tr_results,
			'tracking':tracking,
			'invoice_results':invoice_results,
			'reason_num':reason_num,
			'reason':VER_ERROR_LIST.get(reason_num),
			})
		
		counts.update({
			translate.get(count):translate.get(count,0) + 1
		})
			
		
		return data,counts
	
	def check_tracking(self,data,counts):
		
		tracking_string = data['tracking']
		
	
		tracking_list = [item.strip() for item in tracking_string.split(BARCODE_SEPARATOR)]
		
		if 'NOREAD' in tracking_list:
			data.update({
				'tracking':'NoRead',
				'reason_num':4,
				'reason':VER_ERROR_LIST.get(4),
				})
				
			counts.update({
				'NoRead_tracking_cnt': counts.get('NoRead_tracking_cnt', 0) + 1
			})	
			return data,counts
			
		

		data,counts = self.identify_and_extract(tracking_list,data,counts)
						
		return data,counts
	
	def check_lpn(self,data,counts):
		
		
		lpn_string = data['LPN']
		
		# Use dict.fromkeys() to remove duplicates while preserving order
		LPN_list = list(dict.fromkeys(lpn_string.split(BARCODE_SEPARATOR)))
		if any(x in LPN_list for x in ['NODATA', 'NOREAD']):
			data.update({
				'LPN':'NoRead',
				'reason_num':5,
				'reason':VER_ERROR_LIST.get(5),
				})
				
			counts.update({
				'NoRead_lpn_cnt': counts.get('NoRead_lpn_cnt', 0) + 1
			})	
			return data,counts 
		
		# Use list comprehension to filter valid LPNs
		LPN_list = [lpn for lpn in LPN_list if re.match('^H0\d{6}$', lpn)]

		if not LPN_list:
			data.update({
				'LPN':lpn_string,
				'reason_num':5,
				'reason':VER_ERROR_LIST.get(5),
				})
				
			counts.update({
				'NoRead_lpn_cnt': counts.get('NoRead_lpn_cnt', 0) + 1
			})	
			
			return data,counts		
		
		# H0495315,H0495316
		if len(LPN_list)>1:
			data.update({
				'LPN':','.join(LPN_list),
				'reason_num':19,
				'reason':VER_ERROR_LIST.get(19),
				})
				
			counts.update({
				'multi_lpn_cnt': counts.get('multi_lpn_cnt', 0) + 1
			})	
				
			return data,counts
		
		
		data.update({
			'LPN':LPN_list[0],
			'reason_num':1,
			'reason':VER_ERROR_LIST.get(1),
			})
		
		counts.update({
				'lpn_cnt': counts.get('lpn_cnt', 0) + 1
			})	

		
		
		return data,counts

	def check_cache(self,data,counts):
		
		try:
			cache_results = ExtraGlobal.get(data['LPN'],cached_scope)
			verify = {
				'verification_barcode':cache_results['verification_barcode'],
				'orderNbr':cache_results['orderNbr'],
				}
		except:
			
			
			
			filter = {'$and':[{"LPN":data['LPN']},{'process':'Print'}]}
			sort={'start_time': -1}
			query_results = db_access.select_records(db_name, 'HSL_info',where_clause=filter)
			
			if not query_results:
				data.update({
				'tracking':'No Match',
				'orderNbr':'No Match',
				'reason_num':6,
				'reason':VER_ERROR_LIST.get(6),
				})
				counts.update({
					'not_in_db/cache_cnt': counts.get('not_in_db/cache_cnt', 0) + 1
				})	
			
				return data,counts
			
			verify = {
				'verification_barcode':query_results['verification_barcode'],
				'orderNbr':query_results['orderNbr'],
				}
				
		data.update({
			'reason_num':1,
			'reason':VER_ERROR_LIST.get(1),
				})
		
		return data,counts,verify

	def verify_lookup(self,data,counts,verify):
		
		if data['reason_num'] in [1]:
			
			trackingNum = self.identify_tracking_number(trackingList = data['tracking_list'])
					
			if verify.get('verification_barcode') in trackingNum:#  '1Z7759450308521742' in  [1Z7759450308521742]
				
				data.update({
				'verification_barcode':verify.get('verification_barcode'),
				'orderNbr':verify.get('orderNbr'),
				'reason_num':1,
				'reason':VER_ERROR_LIST.get(1),
				})
				
				counts.update({
					'Verified_cnt': counts.get('Verified_cnt', 0) + 1
				})
				
			else:
				data.update({
				'verification_barcode':'No Match',
				'orderNbr':'',
				'reason_num':3,
				'reason':VER_ERROR_LIST.get(3),
				})
				counts.update({
					'Mismatched_cnt': counts.get('Mismatched_cnt', 0) + 1
				})
	
		elif data['reason_num'] in [17,21]:
			
			if verify['orderNbr'] in data['invoice_results']:
				reason_num = 1 if data['reason_num'] == 17 else 21
				data.update({
					'verification_barcode':verify.get('verification_barcode'),
					'orderNbr':verify.get('orderNbr'),
					'reason_num': reason_num,
					'reason':VER_ERROR_LIST.get(reason_num),
					})
				counts.update({
					'Verified_cnt': counts.get('Verified_cnt', 0) + 1
				})
				
			else:
				
				data.update({
					'verification_barcode':'',
					'orderNbr':'No Match',
					'reason_num':3,
					'reason':VER_ERROR_LIST.get(3),
					})
				counts.update({
					'Mismatched_cnt': counts.get('Mismatched_cnt', 0) + 1
				})
		
		else:
			data.update({
				'verification_barcode':'',
				'orderNbr':'',
				})
					
	
		#----should update with error message if not matching 1 16 or 21 16 and 21	
		#
		#--- if 2-20 should come here with reason and message 
		OPCSERVER = 'Ignition OPC-UA Server'
		itemPaths = [
			'ns=1;s=[{0}]IGNHSLVerifyResult[{1}]'.format(plcname,data['indexId']),
			'ns=1;s=[{0}]IGNReturnedHSLVerifyIndexID'.format(plcname)
		]
		system.opc.writeValues(OPCSERVER, itemPaths, [data['reason_num'],int(data['indexId'])])
			
			
		return data,counts